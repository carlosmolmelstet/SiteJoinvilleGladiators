/ *! jQuery v3.5.0 | (c) JS Foundation e outros colaboradores | jquery.org/license * /
! function (e, t) { "use strict"; "object" == typeof module && "object" == typeof module.exports ? module.exports ? module.exports = e.document ? t(e, !0) : function (e) { if (!e.document) lança novo erro("jQuery requer uma janela com um documento"); retorna t(e) } : t(e)}("indefinido"! = tipo de janela ? window : this, function (C, e) { "use strict"; var t = [], r = Object.getPrototypeOf, s = t.slice, g = t.flat ? Função(e) { return t.flat.call (e) }: função(e) { retornar t.concat.apply([], e) }, u = t.push, i = t.indexOf, n = {}, o = n.toString, v = n.hasOwnProperty, a = v.toString, l = a.call(Object), y = {}, m = function (e) { return "function" == tipo de e && "número"! = tipo de e.nodeType }, x = função(e) { return null! = e && e === e.window }, E = C.document, c = { type: !0, src: !0, nonce: !0, noModule: !0 }; function b(e, t, n) { var r, i, o = (n = n || E).createElement("script"); if (o.text = e, t) para(r em c)(i = t[r] || t.getAttribute && t.getAttribute(r)) && o.setAttribute(r, i); n.head.appendChild(o).parentNode.removeChild(o) } função w(e) { return null == e ? e + "" : "objeto" == tipo de e || "função" == tipo de e ? n[o.call(e)] || "objeto" : tipo de e } var f = "3.5.0", S = função(e, t) { retorna novo S.fn.init (e, t)}; função p(e) { var t = !!e && "length" em e && e.length, n = w(e); return !m(e) && !x(e) && ("array" === n || 0 === t || " número " == tipo de t && 0 < t && t - 1 em e) } S.fn = S.prototype = { jquery: f, construtor: S, comprimento: 0, toArray: function () { return s.call(this) }, get: function (e) { return null == e ? s.call(this) : e < 0 ? this[e + this.length] : this[e] }, pushStack: function (e) { var t = S.merge(this.constructor(), e); return t.prevObject = this, t }, cada um: function (e) { return S.each(this, e) }, map: function (n) { return this.pushStack(S.map(this, function (e, t) { return n.call(e, t, e) })) }, fatia: function () { retorna this.pushStack(s.apply(isto, argumentos)) }, primeiro: function () { retorna this.eq(0) }, ultimo: function () { retorna this.eq(-1) }, par: function () { retorna this.pushStack(S.grep(esta, função(e, t) { return(t + 1) % 2})) }, ímpar: function () { return this.pushStack(S.grep(this, function (e, t) { return t % 2 })) }, eq: function (e) { var t = this.length, n = + e + (e < 0 ? T : 0); retorna this.pushStack(0 <= n && n < t ? [This[n]] : []) }, end: function () { retorna this.prevObject || this.constructor() } , pressione: u, classifique: t.sort, emenda: t.splice}, S.extend = S.fn.extend = function () { var e, t, n, r, i, o, a = argumentos[0] || {}, s = 1, u = argumentos.length, l = !1; para("booleano" == tipo de a && (l = a, a = argumentos[s] || {}, s++), " objeto " == tipo de a || m(a) || (a = {}), s === u && (a = this, s -); s < u; s++) if (null! = (e = argumentos[s])) para(t em e) r = e[t], "__ proto __"! == t && a! == r && (l && r && (S.isPlainObject(r) || (i = Array.isArray(r))) ? (n = a[t], o = i && !Array.isArray(n) ? [] : i || S.isPlainObject(n) ? n : {}, i = !1, a[t] = S.extensão(l, o, r)) : void 0! == r && (a[t] = r)); retorne a }, S.extend({ expando: "jQuery" + (f + Math.random()).Replace(/ \ D / g, ""), isReady: !0, erro: function (e) { throw new Error(e) }, noop: function () { }, isPlainObject: function (e) { var t, n; return !(!e || "[objeto Objeto]"! == o.call(e)) && (!(t = r(e)) || "function" == typeof (n = v.call(t, "construtor") && t.constructor) && t.constructor) && a.call(n) === l)}, isEmptyObject: function (e) { var t; para(t em e) return !1; return !0 }, globalEval: function (e, t, n) { b(e, { nonce: t && t.nonce }, n) }, cada um: função(e, t) { var n, r = 0; se(p(e)) { para(n = e.length; r < n; r++) if (!1 === t.call(e[r], r, e[r])) break } else para(r em e) if (!1 === t.call(e[r], r, e[r])) break; return e }, makeArray: function (e, t) { var n = t || []; return null! = e && (p(Object(e)) ? S.merge(n, "string" == tipo de e ? [E] : e) : u.call(n, e)), n }, inArray: function (e, t, n) { return null == t ? -1 : i.call(t, e, n) }, mesclagem: function (e, t) { for (var n = + comprimento t, r = 0, i = comprimento e; r < n; r++) e[i++] = t[r]; retorno e.length = i, e }, grep: function (e, t, n) { para(var r = [], i = 0, o = e.length, a = !n; i < o; i++) !t(e[i], i)! == a && r.push(e[i]); return r }, map: function (e, t, n) { var r, i, o = 0, a = []; if (p(e)) for (r = comprimento.de; o < r; o++) null! = (i = t(e[o], o, n)) && a.push(i); else for (o in e) null! = (i = t(e[o], o, n)) &&.push(i); return g(a) } , guid: 1, suporte: y}), "function" == typeof Symbol && (S.fn[Symbol.iterator] = t[Symbol.iterator]), S.each("Número booleano String Função Matriz Data RegExp Objeto Símbolo de erro ".split(" "), função(e, t) { n [" [objeto " + t + "] "] = t.toLowerCase() }); var d = function (n) { var e, d, b, o, i, h, f, g, w, u, l, T, C, a, E, v, s, c, y, S = "chiar" + 1 * new Date, p = n.documento, k = 0, r = 0, m = ue(), x = ue(), A = ue(), N = ue(), D = função(e, t) { return e === t && (l = !0), 0 }, j = {}.hasOwnProperty, t = [], q = t.pop, L = t.push, H = t.push, O = t.slice, P = função(e, t) { for (var n = 0, r = e.length; n < r; n++) se(e[n] === t) retornar n; return -1}, R = "marcado | selecionado | assíncrono | foco automático | reprodução | controles | adiar | desativado | oculto | ismap | loop | múltiplo | aberto | somente leitura | necessário | escopo", M = "[\\ x20 \\ t \\ r \ \ n \\ f] ", I = " (?: \\\\ [\ da da fA-F] {1,6} " + M + "? | \\\\ [^ \\ r \\ n \\ f] | [\\ w-] | [^ \ 0 - \\ x7f]) + ", W = " \\ [" + M + " * (" + I + ") (?: " + M + " * ([* ^ $ |! ~]? =) " + M + " * (?:'((?: \\\\. | [^ \\\\']) *) '| \ "((?: \\\\. | [^ \\\\\"]) *) \ " | ("+ I +")) |) "+ M +" * \\]", F =" : ("+ I +")(?: \\((('((?: \\\\. | [ ^ \\\\ ']) *) ' | \ "((?: \\\\. | [^ \\\\\"]) *) \ ") | ((?: \\\\. | [^ \\\\ () [\\]] | "+ W +") *) |. *) \\) |) ", B = novo RegExp (M +" + "," g "), $ = novo RegExp ("^" + M + "+ | ((?: ^ | [^ \\\\]) (?: \\\\.) *)" + M + "+ $", "g"), _ = novo RegExp ("^" + M + "*," + M + "*"), z = novo RegExp ("^" + M + "* ([> + ~] |" + M + ")" + M + "*") , U = novo RegExp (M + "|>"), X = novo RegExp (F), V = novo RegExp ("^" + I + "$"), G = {ID: new RegExp ("^ # (" + I + ")"), CLASS: new RegExp ("^ \\. (" + I + ")"), TAG: new RegExp ("^ (" + I + "| [*])"), ATTR: new RegExp ( "^ "+ W), PSEUDO: novo RegExp (" ^ "+ F), FILHO: novo RegExp (" ^ :( somente | primeiro | último | enésimo | enésimo-último) - (filho | do tipo) (?: \\ ("+ M +" * (par | ímpar | (([+ -] |) (\\ d *) n |) ") + M +" * (?: ([+ -] |) "+ M +" * (\\ d +) |)) "+ M +" * \\) |) "," i "), bool: new RegExp (" ^ (?: "+ R +") $ "," i "), needsContext: new RegExp ("^" + M + "* [> + ~] |: (par | ímpar | eq | gt | lt | enésimo | primeiro | último) (?: \\ (" + M + "* ((?: - \\ d)? \\ d *) "+ M +" * \\) |) (? = [^ -] | $) "," i ")}, Y = / HTML $ / i, Q = / ^ (?: input | select | textarea | button) $ / i, J = / ^ h \ d $ / i, K = / ^ [^ {] + \ {\ s * \ [nativo \ w /, Z = / ^ (?: # ([\ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, ee = / [+ ~] /, te = new RegExp ("\\ \\ [\\ da-fA-F] {1,6} "+ M +"? | \\\\ ([^ \\ r \\ n \\ f]) "," g "), ne = function (e, t) {var n = "0x" + e.slice (1) -65536; retorna t || (n <0? String.fromCharCode (n + 65536): String.fromCharCode (n >> 10 | 55296,1023 & n | 56320))}, re = / ([\ 0- \ x1f \ x7f] | ^ -? \ d) | ^ - $ | [^ \ 0- \ x1f \ x7f - \ uFFFF \ w -] / g, ie = função (e, t) {retornar t? "\ 0" === e? "\ ufffd": e.slice (0, -1) + "\\" + e.charCodeAt (e.length-1) .toString (16) + "": "\\" + e}, oe = função () {T ()}, ae = be (função (e) {return! 0 === e.disabled && "fieldset" === e.nodeName.toLowerCase ()}, {dir: "parentNode", próximo: "legend"}); tente {H.apply (t = O.call (p .childNodes), p.childNodes), t [p.childNodes.length] .nodeType} catch (e) {H = {apply: t.length? function (e, t) {L.apply (e, O.call (t))}: function (e, t) {var n = e.length, r = 0; while (e [n ++] = t [r ++]); e.length = n-1}}} function se ( t, e, n, r) {var i, o, a, s, u, l, c, f = e && e.ownerDocument, p = e? e.nodeType: 9; if (n = n || [], "string"! = tipo de t ||! t || 1! == p && 9! == p && 11! == p) return n; if (! r && (T (e), e = e || C,E)) {if (11! == p && (u = Z.exec (t))) if (i = u [1]) {if (9 === p) {if (! (A = e.getElementById (i))) return n; if (a.id === i) retorna n.push (a), n} else if (f && (a = f.getElementById (i)) && y (e, a) && a. id === i) retorna n.push (a), n} mais {if (u [2]) retorna H.apply (n, e.getElementsByTagName (t)), n; if ((i = u [3 ]) && d.getElementsByClassName && e.getElementsByClassName) retorna H.apply (n, e.getElementsByClassName (i)), n} if (d.qsa &&! N [t + ""] && (! v ||! v.test (t) ) && (1! == p || "objeto"! == e.nodeName.toLowerCase ())) {if (c = t, f = e, 1 === p && (U.test (t) || z.test (t))) {(f = ee.test (t) && ye (e.parentNode) || e) === e && d.scope || ((s = e.getAttribute ("id")))? s = s.replace (re, ie): e.setAttribute ("id", s = S)), o = (l = h (t)). length; while (o -) l [o] = ( s? "#" + s: ": escopo") + "" + xe (l [o]); c = l.join (",")} tente {retornar H.apply (n, f.querySelectorAll (c)), n} captura (e) {N (t,! 0)} finalmente {s === S&& e.removeAttribute (" id ")} }} return g (t.replace ($, "$ 1"), e, n, r)} função ue () {var r = []; função de retorno e (t, n) {return r.push (t + " ")> b.cacheLength && delete e [r.shift ()], e [t +" "] = n}} função le (e) {return e [S] =! 0, e} função ce (e) {var t = C.createElement ("fieldset"); tente {return !! e (t)} catch (e) {return! 1} finalmente {t.parentNode && t.parentNode.removeChild (t), t = null}} função fe ( e, t) {var n = e.split ("|"), r = n.length; while (r -) b.attrHandle [n [r]] = t} função pe (e, t) {var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex-t.sourceIndex; if (r) retorna r; if (n) while (n = n.nextSibling) if (n == = t) retorno-1; retorno e? 1: -1} função de (t) {função de retorno (e) {retorno "entrada" === e.nodeName.toLowerCase () && e.type === t}} function he (n) {return function (e) {var t = e.nodeName.toLowerCase (); return ("input" === t || "botão "=== t) && e.type === n}} função ge (t) {retornar função (e) {retornar" formulário "no e? e.parentNode &&! 1 === e.disabled?" label "in e? "label" em e.parentNode? e.parentNode.disabled === t: e.disabled === t: e.isDisabled === t || e.isDisabled! ==! t && ae (e) == = t: e.disabled === t: "label" em e && e.disabled === t}} função ve (a) {return le (função (o) {return o = + o, le (function (e, t) {var n, r = a ([], e.length, o), i = r.length; enquanto (i -) e [n = r [i]] && (e [n] =! ( t [n] = e [n]))})})} função ye (e) {return e && "undefined"! = tipo de e.getElementsByTagName && e} para (e em d = se.support = {}, i = se .isXML = função (e) {var t = e.namespaceURI, n = (e.ownerDocument || e) .documentElement;return! Y.test (t || n && n.nodeName || "HTML")}, T = se.setDocument = função (e) {var t, n, r = e? e.ownerDocument || e: p; return r! = C && 9 === r.nodeType && r.documentElement && (a = (C = r) .documentElement, E =! i (C), p! = C && (n = C.defaultView) && n.top! == n && ( n.addEventListener? n.addEventListener ("descarregar", oe,! 1): n.attachEvent && n.attachEvent ("onunload", oe)), d.scope = ce (função (e) {retornar a.appendChild (e) .appendChild (C.createElement ("div")), "indefinido"! = tipo de e.querySelectorAll &&! e.querySelectorAll (": escopo fieldset div"). comprimento}), d.attributes = ce (function (e) { retornar e.className = "i",! e.getAttribute ("className")}), d.getElementsByTagName = ce (função (e) {retornar e.appendChild (C.createComment ("")) ,! e.getElementsByTagName ("*").comprimento}), d.getElementsByClassName = K.test (C.getElementsByClassName), d.getById = ce (função (e) {retornar a.appendChild (e) .id = S,! C.getElementsByName ||! C.getElementsByName (S) .length}), d.getById? (B.filter.ID = function (e) {var t = e.replace (te, ne); função de retorno (e) {return e.getAttribute ("id" ) === t}}, b.find.ID = function (e, t) {if ("undefined"! = tipo de t.getElementById && E) {var n = t.getElementById (e); return n? [n] : []}}) :( b.filter.ID = função (e) {var n = e.replace (te, ne); função de retorno (e) {var t = "indefinido"! = tipo de e.getAttributeNode && e. getAttributeNode ("id"); return t && t.value === n}}, b.find.ID = function (e, t) {if ("undefined"! = tipo de t.getElementById && E) {var n, r, i , o = t.getElementById (e); if (o) {if ((n = o.getAttributeNode ("id")) && n.value === e) return [o]; i = t.getElementsByName (e) , r = 0;while (o = i [r ++]) if ((n = o.getAttributeNode ("id")) && n.value === e) retornar [o]} retornar []}}), b.find.TAG = d função .getElementsByTagName? (e, t) {retornar "indefinido"! = tipo de t.getElementsByTagName? t.getElementsByTagName (e): d.qsa? t.querySelectorAll (e): vazio 0}: função (e, t) { var n, r = [], i = 0, o = t.getElementsByTagName (e); if ("*" === e) {while (n = o [i ++]) 1 === n.nodeType && r.push (n); return r} return o}, b.find.CLASS = d.getElementsByClassName && function (e, t) {if ("undefined"! = tipo de t.getElementsByClassName &&)) retorna t.getElementsByClassName (e)}, s = [ ], v = [], (d.qsa = K.test (C.querySelectorAll)) && (ce (função (e) {var t; a.appendChild (e) .innerHTML = "<a id = '" + S + "'> </a> <selecione id ='" + S + " - \ r \\ 'msallowcapture =' '> <opção selecionada =' '> </ option> </select> ", e.querySelectorAll (" [msallowcapture ^ = ''] "). length && v.push (" [* ^ $] = "+ M +" * (?: '' | \ "\" ) "), e.querySelectorAll (" [selected] "). length || v.push (" \\ ["+ M +" * (?: valor | "+ R +") "), e.querySelectorAll (" [ id ~ = "+ S +" -] "). length || v.push (" ~ = "), (t = C.criarElement (" entrada ")). setAttribute (" name "," "), e. appendChild (t), e.querySelectorAll ("[name = '']"). length || v.push ("\\ [" + M + "* name" + M + "* =" + M + "* (?: '' | \ "\") "), e.querySelectorAll (": marcado "). length || v.push (": marcado "), e.querySelectorAll (" a # "+ S +" + * "). length || v.push (". #. + [+ ~]"), e.querySelectorAll ("\\\ f"), v.push ("[\\ r \\ n \\ f]")}), ce (função (e) {e.innerHTML = "<a href='' disabled='disabled'> </a> <selecione desativado = 'desativado'> <opção /> </select> "; var t = C.criarElement (" entrada "); t.setAttribute (" tipo "," oculto "), e.appendChild (t) .setAttribute (" nome "," D "), e.querySelectorAll (" [name = d] "). length && v.push (" nome "+ M +" * [* ^ $ |! ~]? = "), 2! == e .querySelectorAll (": enabled"). length && v.push (": enabled", ": disabled"), a.appendChild (e) .disabled =! 0,2! == e.querySelectorAll (": disabled"). length && v.push (": enabled", ": disabled"), e.querySelectorAll ("* ,: x"), v.push (",. *:")})), (d.matchesSelector = K.test (c = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && ce (função (e) {d.disconnectedMatch = c.call (e, "*"), c.call (e, "[s! = '']: x "), s.push ("! = ", F)}), v = comprimento.v & novo RegExp (v.join (" | ")), s = comprimento.v && novo RegExp (s.join (" | ") ), t = K.test (a.compareDocumentPosition), y = t || K.test (a.contains)? function (e, t) {var n = 9 === e.nodeType? e.documentElement: e , r = t && t.parentNode; return e === r ||! (! r || 1! == r.nodeType ||! (n.contains? n.contains (r): e.compareDocumentPosition && 16 & e.compareDocumentPosition (r )))}: function (e, t) {if (t) while (t = t.parentNode) if (t === e) return! 0; return! 1}, D = t? function (e, t ) {if (e === t) retorna l =! 0,0; var n =! e.compareDocumentPosition-! t.compareDocumentPosition; retorna n || (1 & (n = (e.ownerDocument || e) ==) (t.ownerDocument || t)? e.compareDocumentPosition (t): 1) || d.sortDetached && t.compareDocumentPosition (e) === n? e == C || e.ownerDocument == p && y (p, e)? - 1: t == C || t.ownerDocument == p && y (p, t)? 1: u? P (u, e) -P (u, t): 0: 4 & n? -1: 1)}: function (e, t) {if (e === t) retorna l =! 0, 0; var n, r = 0, i = e.parentNode, o = t.parentNode, a = [e], s = [t]; se (! I ||! O) retornar e == C? -1 () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () ; n = e; while (n = n.parentNode) a.shift (n); n = t; while (n = n.parentNode) s.unshift (n); while (a [r] === s [ r]) r ++; retorna r? pe (a [r], s [r]): a [r] == p? -1: s [r] == p? 1: 0}), C}, se .matches = função (e, t) {retornar se (e, nulo, nulo, t)}, se.matchesSelector = função (e, t) {se (T (e), d.matchesSelector && E &&! N [t + "" ] && (! s ||! s.test (t)) && (! v ||! v.test (t))) tente {var n = c.call (e, t); if (n || d .disconnectedMatch || e.document && 11! == e.document.nodeType) return n} catch (e) {N (t,! 0)} return 0 <se (t, C, nulo, [e]). length} , se.contém = função (e, t) {return (e.ownerDocument || e)! = C && T (e), y (e, t)}, se.attr = função (e, t) {(e.ownerDocument || e)! = C &&T (e); var n = b.attrHandle [t.toLowerCase ()], r = n && j.call (b.attrHandle, t.toLowerCase ())? n (e, t,! E): void 0; return void 0! == r? r: d.atributos ||! E? e.getAttribute (t) :( r = e.getAttributeNode (t)) && r.especificado? r.value: null}, se .escape = função (e) {retornar (e + ""). substituir (re, ie)}, se.error = função (e) {lançar novo erro ("Erro de sintaxe, expressão não reconhecida:" + e)}, se .uniqueSort = função (e) {var t, n = [], r = 0, i = 0; if (l =! d.detectDuplicates, u =! d.sortStable && e.slice (0), e.sort (D ), l) {while (t = e [i ++]) t === e [i] && (r = n.push (i)); while (r -) e.splice (n [r], 1 )} retornar u = nulo, e}, o = se.getText = função (e) {var t, n = "", r = 0, i = e.nodeType; if (i) {if (1 === i || 9 === i || 11 === i) {if ("string" == tipo de e.textContent) return e.textContent; for (e = e.firstChild; e; e = e.nextSibling) n + = o (e)} else if (3 === i || 4 === i) retorne e.nodeValue } else while (t = e [r ++]) n + = o (t); retorno n}, (b = se.selectors = {cacheLength: 50, createPseudo: le, correspondência: G, attrHandle: {}, encontre: { }, relativo: {">": {dir: "parentNode", primeiro:! 0}, "": {dir: "parentNode"}, "+": {dir: "previousSibling", primeiro:! 0}, "~": {dir: "previousSibling"}}, preFilter: {ATTR: função (e) {retorne e [1] = e [1]. substitua (te, ne), e [3] = (e [3 ] || e [4] || e [5] || ""). substitua (te, ne), "~ =" === e [2] && (e [3] = "" + e [3 ] + ""), e.slice (0,4)}, CRIANÇA: function (e) {return e [1] = e [1] .toLowerCase (), "enésimo" === e [1] .slice (0,3)? (E [3] || se.erro (e [0]), e [4] = + (e [4]? E [5] + (e [6] || 1): 2 * ("par" === e [3] || "ímpar" === e [3])), e [5] = + (e [7] + e [8] || "ímpar "=== e [3])): e [3] && se.error (e [0]), e}, PSEUDO: função (e) {var t, n =! e [6] && e [2] ; return G.CHILD.test (e [0])? null: (e [3]? e [2] = e [4] || e [5] || "": n && X.test (n) && ( t = h (n,! 0)) && (t = n.índice) (")", n.length-t) -n.length) && (e [0] = e [0] .slice (0, t ), e [2] = n.slice (0, t)), e.slice (0,3))}}, filtro: {TAG: function (e) {var t = e.replace (te, ne) .toLowerCase (); return "*" === e? function () {return! 0}: function (e) {return e.nodeName && e.nodeName.toLowerCase () === t}}, CLASSE: function (e ) {var t = m [e + ""]; retorna t || (t = novo RegExp ("(^ |" + M + ")" + e + "(" + M + "| $)") && m (e, função (e) {return t.test ("string" == tipo de e.className && e.className || "indefinido"! = tipo de e.getAttribute && e.getAttribute ("classe") || ""))}}, ATTR:função (n, r, i) {função de retorno (e) {var t = se.attr (e, n); retorno nulo == t? "! =" === r:! r || (t + = " "," = "=== r? t === i:"! = "=== r? t! == i:" ^ = "=== r? i && 0 === t.indexOf (i) : "* =" === r? i && - 1 <t.indexOf (i): "$ =" === r? i && t.slice (-i.length) === i: "~ =" == = r? -1 <("" + t.replace (B, "") + "") .indexDe (i): "| =" === r && (t === i || t.slice (0) , i.length + 1 === i + "-"))}}, CRIANÇA: function (h, e, t, g, v) {var y = "enésimo"! == h.slice (0,3 ), m = "last"! == h.slice (-4), x = "do tipo" === e; return 1 === g && 0 === v? function (e) {return !! e .parentNode}: function (e, t, n) {var r, i, o, a, s, u, l = y! == m? "nextSibling": "previousSibling", c = e.parentNode, f = x && e.nodeName.toLowerCase (), p =! n &&! x, d =! 1; if (c) {if (y) {while (l) {a = e;while (a = a [l]) if (x? a.nodeName.toLowerCase () === f: 1 === a.nodeType) return! 1; u = l = "somente" === h &&! u && "nextSibling"} return! 0} if (u = [m? c.firstChild: c.lastChild], m && p) {d = (s = (r = (i = (o = (a = c) [S] | | (a [S] = {})) [a.uniqueID] || (o [a.uniqueID] = {})) [h] || []) [0] === k && r [1]) && r [2], a = s && c.childNodes [s]; while (a = ++ s && a && a [l] || (d = s = 0) || u.pop ()) if (1 === a.nodeType && + + d && a === e) {i [h] = [k, s, d]; break}} else if (p && (d = s = (r = (i = (o = (a = e) [S] || (a [S] = {})) [a.uniqueID] || (o [a.uniqueID] = {})) [h] || []) [0] === k && r [1]) ,! 1 === d) while (a = ++ s && a && a [l] || (d = s = 0) || u.pop ()) if ((x? A.nodeName.toLowerCase () ===) f: 1 === a.nodeType) && ++ d && (p && ((i = (o = a [S] || (a [S] = {})) [a.uniqueID] || (o [a .uniqueID] = {})) [h] = [k, d]), a === e)) break; return (d- = v) === g || d% g == 0 && 0 <= d / g}}}, PSEUDO:função (e, o) {var t, a = b.pseudos [e] || b.setFilters [e.toLowerCase ()] || se.error ("pseudo não suportado:" + e); retorne [S] ? a (o): 1 <a.length? (t = [e, e, "", o], b.setFilters.hasOwnProperty (e.toLowerCase ())? le (function (e, t) {var n , r = a (e, o), i = r.length; enquanto (i -) e [n = P (e, r [i])] =! (t [n] = r [i])} ): function (e) {retorna a (e, 0, t)}): a}}, pseudos: {not: le (function (e) {var r = [], i = [], s = f ( e.replace ($, "$ 1")); return s [S]? le (função (e, t, n, r) {vari, o = s (e, null, r, []), a = e.length; while (a -) (i = o [a]) && (e [a] =! (t [a] = i))}): function (e, t, n) {return r [ 0] = e, s (r, nulo, n, i), r [0] = nulo,! I.pop ()}}), possui: le (função (t) {função de retorno (e) {retorno 0 <se (t, e) .length}}), contém: le (função (t) {return t = t.replace (te, ne), função (e) {return-1 <(e.textContent || o (e)). indexOf (t)}}), lang: le (função (n) {retorna V.test (n || "") || se.error ("lang não suportado:" + n),n = n.replace (te, ne) .toLowerCase (), function (e) {var t; do {if (t = E? e.lang: e.getAttribute ("xml: lang") || e.getAttribute ("lang")) return (t = t.toLowerCase ()) === n || 0 === t.indexOf (n + "-")} enquanto ((e = e.parentNode) && 1 === e .nodeType); return! 1}}), target: function (e) {var t = n.location && n.location.hash; return t && t.slice (1) === e.id}, root: function (e) {return e === a}, focus: function (e) {return e === C.activeElement && (! C.hasFocus || C.hasFocus || C.hasFocus ()) && !! (e.type || e.href | | ~ e.tabIndex)}, ativado: ge (! 1), desabilitado: ge (! 0), verificado: função (e) {var t = e.nodeName.toLowerCase (); return "input" === t && !! e.checked || "opção" === t && !! e.selected}, selecionado: function (e) {return e.parentNode && e.parentNode.selectedIndex,! 0 === e.selected}, vazio: function (e) {for (e = e.firstChild; e; e = e.nextSibling) if (e.nodeType <6) return! 1; return! 0}, pai: função (e) {retorno! B.pseudos.empty (e)}, cabeçalho: função (e) {retorno J.test (e.nodeName)}, entrada: function (e) {return Q.test (e.nodeName)}, button: function (e) {var t = e.nodeName.toLowerCase (); return "input" === t && "button" === e. digite || "botão" === t}, texto: função (e) {var t; retorne "entrada" === e.nodeName.toLowerCase () && "text" === e.type && (null == (t = e.getAttribute ("tipo")) || "texto" === t.toLowerCase ())}, primeiro: ve (function () {return [0]}), último: ve (function (e , t) {return [t-1]}), eq: ve (função (e, t, n) {return [n <0? n + t: n]}), even: ve (função (e, t ) {for (var n = 0; n <t; n + = 2) e.push (n); return e}), ímpar: ve (função (e, t) {for (var n = 1; n <t ; n + = 2) e.push (n); return e}), lt: ve (function (e, t, n) {for (var r = n <0? n + t: t <n? t: n ; 0 <= - r;) e.push (r); retorno e}), gt: ve (função (e, t,n) {para (var r = n <0? n + t: n; ++ r <t;) e.push (r); retorno e})}}). pseudos.nth = b.pseudos.eq, {radio:! 0, caixa de seleção:! 0, arquivo:! 0, senha:! 0, imagem:! 0}) b.pseudos [e] = de (e); para (e em {submit:! 0, redefinir :! 0}) b.pseudos [e] = ele (e); função me () {} função xe (e) {para (var t = 0, n = comprimento e, r = ""; t <n ; t ++) r + = e [t] .valor; return r} função be (s, e, t) {var u = e.dir, l = e.próximo, c = l || u, f = t && "parentNode "=== c, p = r ++; retorna e.first? função (e, t, n) {while (e = e [u]) if (1 === e.nodeType || f) retorna s (e , t, n); return! 1}: function (e, t, n) {var r, i, o, a = [k, p]; se (n) {while (e = e [u]) se ((1 === e.nodeType || f) && s (e, t, n)) retorne! 0} else while (e = e [u]) if (1 === e.nodeType || f) se (i = (o = e [S] || (e [S] = {})) [e.uniqueID] || (o [e.uniqueID] = {}), l && l === e.nodeName.toLowerCase ()) e = e [u] || e; senão {se ((r = i [c]) && r [0] === k && r [1] === p) retornar a [2] = r [2 ]; se ((i [c] = a) [2] = s (e, t, n)) retorne! 0} retorne!1}} função we (i) {return 1 <comprimento i? Função (e, t, n) {var r = comprimento i; while (r -) if (! I [r] (e, t, n)) return! 1; return! 0}: i [0]} função Te (e, t, n, r, i) {for (var o, a = [], s = 0, u = e.length , l = nulo! = t; s <u; s ++) (o = e [s]) && (n &&! n (o, r, i) || (a.push (o), l &&t.push (s) )); return a} function Ce (d, h, g, v, y, e) {return v &&! v [S] && (v = Ce (v)), y &&! y [S] && (y = Ce (y, e)), le (função (e, t, n, r) {var i, o, a, s = [], u = [], l = comprimento de t, c = e || função ( e, t, n) {para (var r = 0, i = comprimento t; r <i; r ++) se (e, t [r], n); retorno n} (h || "*", n .nodeType? [n]: n, []), f =! d ||! e && h? c: Te (c, s, d, n, r), p = g? y || (e? d: l || v)? []: t: f; se (g && g (f, p, n, r), v) {i = Te (p, u), v (i, [], n, r), o = i.length; while (o -) (a = i [o]) && (p [u [o]] =! (f [u [o]] = a))} if (e) {if ( y || d) {if (y) {i = [], o = p.length; while (o -) (a = p [o]) && i.push (f [o] = a); y ( null, p = [], i, r)} o = p.length; while (o -) (a = p [o]) && -1 <(i = y? P (e, a): s [o]) && (e [i] =! (T [i] = a))}} else p = Te (p === t ? p.splice (l, p.length): p), y? y (null, t, p, r): H.apply (t, p)})} função Ee (e) {for (var i, t, n, r = e.length, o = b.relativo [e [0] .tipo], a = o || b.relativo [""], s = o? 1: 0, u = be (função (e) {retornar e === i}, a,! 0), l = ser (função (e) {retornar-1 <P (i, e)}, a,! 0), c = [função ( e, t, n) {var r =! o && (n || t! == w) || ((i = t) .nodeType? u (e, t, n): l (e, t, n) ); return i = null, r}]; s <r; s ++) if (t = b.relative [e [s] .type]) c = [be (we (c), t)]; else {if ((t = b.filtro [e [s]. tipo] .apply (null, e [s] .matches)) [S]) {for (n = ++ s; n <r; n ++) if (b .relative [e [n] .type]) break; return Ce (1 <s && we (c), 1 <s && xe (e.slice (0, s-1) .concat ({value: "" === e [ s-2] .type? "*": ""})). replace ($, "$ 1"), t, s <n && Ee (e.slice (s, n)), n <r && Ee (e = e. fatia (n)), n <r && xe (e))} c.push (t)} return we (c)} return me.prototype = b.filters = b.pseudos, b.setFilters = new me, h = se.tokenize = function (e, t) {var n, r, i , o, a, s, u, l = x [e + ""]; se (l) retornar t? 0: l.slice (0); a = e, s = [], u = b.preFilter; while (a) {for (o em n &&! (r = _. exec (a)) || (r && (a = a.slice (r [0] .length) || a), s.push (i = [ ])), n =! 1, (r = z.exec (a)) && (n = r.shift (), i.push ({valor: n, tipo: r [0] .replace ($, " ")}), a = fatia (n.length)), filtro b)! (r = G [o] .exec (a)) || u [o] &&! (r = u [o] (r)) || (n = r.shift (), i.push ({valor: n, tipo: o, corresponde a: r}), a = a.slice (n.length)); if (! n ) break} return t? a.length: a? se.error (e): x (e, s) .slice (0)}, f = se.compile = function (e, t) {var n, v, y, m, x, r, i = [], o = [], a = A [e + ""]; se (! a) {t || (t = h (e)), n = comprimento de t ; while (n -) (a = Ee (t [n])) [S]? i.push (a): o.push (a); (a = A (e, (v = o, m = 0 <(y = i) .comprimento, x = 0 <v.comprimento, r = função (e, t, n, r, i) {var o, a, s, u = 0, l = "0", c = e && [], f = [], p = w, d = e || x && b.find.TAG ("*", i), h = k + = nulo == p? 1: Math.random () ||. 1, g = comprimento d; para (i && (w = t == C || t || i); l! == g && null! = (O = d [l]); l ++) {if (x && o) { a = 0, t || o.ownerDocument == C || (T (o), n =! E); while (s = v [a ++]) if (s (o, t || C, n)) {r.push (o); break} i && (k = h)} m && ((o =! s && o) && u -, e && c.push (o))} if (u + = l, m && l! == u) { a = 0; while (s = y [a ++]) s (c, f, t, n); if (e) {if (0 <u) enquanto (l -) c [l] || f [l ] || (f [l] = q.call (r)); f = Te (f)} H.aplicar (r, f), i &&! e && 0 <comprimento f && 1 <u + y.length && se.uniqueSort (r )} return i && (k = h, w = p), c}, m? le (r): r))). seletor = e} retorna a}, g = se.select = function (e, t, n , r) {var i, o, a, s, u, l = "função" == tipo de e && e, c =! r && h (e = l.selector || e); if (n = n || [], 1 === comprimento c) {if (2 <(o = c [0] = c [0]. Fatia (0)). Length && "ID" === (a = o [0]).digite && 9 === t.nodeType && E && b.relative [o [1] .type]) {if (! (t = (b.find.ID (a.matches [0]. substitua (te, ne), t) || []) [0])) return n; l && (t = t.parentNode), e = e.slice (o.shift (). Value.length)} i = G.needsContext.test (e)? 0: o.length; while (i -) {if (a = o [i], b.relative [s = a.type]) quebra; if ((u = b.find [s]) && (r = u (a.matches [0] .replace (te, ne), ee.test (o [0] .type) && ye (t.parentNode) || t))) {if (o.splice (i, 1), ! (e = r.length && xe (o))) return H.apply (n, r), n; break}}} return (l || f (e, c)) (r, t,! E, n, ! t || ee.test (e) && ye (t.parentNode) || t), n}, d.sortStable = S.split (""). sort (D) .join ("") === S , d.detectDuplicates = !! l, T (), d.sortDetached = ce (função (e) {return 1 & e.compareDocumentPosition (C.createElement ("fieldset"))})), ce (function (e) {return e .innerHTML = "<a href='#'> </a>", "#" === e.firstChild.getAttribute ("href")}) || fe ("type | href | height | width", função (e, t, n) {if (! n) retorna e.getAttribute (t, "type" == = t.toLowerCase ()? 1: 2)}), d.attributes && ce (function (e) {return e.innerHTML = "<input />", e.firstChild.setAttribute ("value", ""), " "=== e.firstChild.getAttribute (" valor ")}) || fe (" valor ", função (e, t, n) {if (! n &&" input "=== e.nodeName.toLowerCase () ) return e.defaultValue}), ce (function (e) {return null == e.getAttribute ("disabled")}) || fe (R, função (e, t, n) {var r; if (! n) return! 0 === e [t]? t.toLowerCase () :( r = e.getAttributeNode (t)) && r.specified? r.value: null}), se} (C); S. encontrar = d, S.expr = d.seletores, S.expr [":"] = S.expr.pseudos, S.uniqueSort = S.unique = d.uniqueSort, S.text = d.getText, S.isXMLDoc = d.isXML, S.contains = d.contains, S.escapeSelector = d.escape; var h = função (e, t, n) {var r = [], i = nulo 0! == n; while ((e = e [t]) && 9! == e.nodeType ) if (1 === e.nodeType) {if (i && S (e) .is (n)) break; r.push (e)} retorna r}, T = função (e, t) {for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e! == t && n.push (e); retorno n}, k = S.expr.match.needsContext; função A (e, t) {return e.nodeName && e.nodeName.toLowerCase () === t.toLowerCase ()} var N = / ^ <([az] [^ \ / \ 0>: \ x20 \ t \ r \ n \ f] * ) [\ x20 \ t \ r \ n \ f] * \ /?> (?: <\ / \ 1> |) $ / i; função D (e, n, r) {return m (n)? S .grep (e, função (e, t) {return !! n.call (e, t, e)! == r}): n.nodeType? S.grep (e, função (e) {return e = == n! == r}): "string"! = tipo de n? S.grep (e, função (e) {return-1 <chamada i (n, e)! == r}): S. filter (n, e, r)} S.filter = função (e, t, n) {var r = t [0]; retorna n && (e = ": not (" + e + ")"), 1 == = comprimento t && 1 === r.nodeType? S.find.matchSelector (r, e)? [r]: []: S. encontrar.matches (e, S.grep (t, função (e) {return 1 === e.nodeType}))}, S.fn. extensão ({find: function (e) {var t, n, r = this.length, i = this; if ("string"! = typeof e) retorna this.pushStack (S (e) .filter (function () {for (t = 0; t <r; t ++) if (S. contém (i [t], isto)) retorna! 0})); for (n = this.pushStack ([]), t = 0; t <r; t ++) S. encontrar (e, i [t], n); return 1 <r? S.uniqueSort (n): n}, filter: function (e) {return this.pushStack (D (this , e || [] ,! 1))}, não: function (e) {return this.pushStack (D (this, e || [] ,! 0))}, é: function (e) {return! ! D (this, "string" == tipo de e &&k.test (e)? S (e): e || [] ,! 1) .length}}); var j, q = / ^ (?: \ S * (<[\ w \ W] +>) [^>] * | # ([\ w -] +)) $ /; (S.fn.init = function (e, t, n) {var r, i; if (! e) retorna isso; if (n = n || j, "string" == tipo de e) {if (! (r = "<" === e [0] && ">" == = e [e.length-1] && 3 <= e.length? [nulo, e, nulo]: q.exec (e)) ||! r [1] && t) return! t || t.jquery? (t || n) .find (e): este.construtor (t) .find (e); if (r [1]) {if (t = t instância de S? T [0]: t, S.merge (isto, S.parseHTML (r [1], t && t.nodeType? T.ownerDocument || t: E,! 0 )), N.test (r [1]) && S.isPlainObject (t)) para (r em t) m (este [r])? Isto [r] (t [r]): this.attr (r, t [r]); retorne isso} return (i = E.getElementById (r [2])) && (this [0] = i, this.length = 1), this} retorne e.nodeType? (this [0 ] = e, this.length = 1, this): m (e)? void 0! == n.ready? n.ready (e): e (S): S.makeArray (e, isso)}). prototype = S.fn, j = S (E); var L = / ^ (?: pais | prev (?: Até | Todos)) /, H = {filhos:! 0, conteúdo:! 0, próximo :! 0, prev:! 0}; função O (e, t) {while ((e = e [t]) && 1! == e.nodeType); retornar e} S.fn.extend ({has: function (e ) {var t = S (e, isto), n = t.length; retorna this.filter (function () {for (var e = 0; e <n; e ++) if (S.contains (this, t [ e])) return! 0})}, mais próximo: function (e, t) {var n, r = 0, i = this.length, o = [],a = "string"! = tipo de e && S (e); if (! k.test (e)) para (; r <i; r ++) para (n = this [r]; n && n! == t; n = n .parentNode) if (n.nodeType <11 && (a? -1 <a.index (n): 1 === n.nodeType && S.find.matchesSelector (n, e))) {o.push (n); break } retorna this.pushStack (1 <comprimento.? S.uniqueSort (o): o)}, índice: function (e) {return e? "string" == tipo de chamada? (S (e), this [0]): i.call (this, e.jquery? e [0]: e): this [0] && this [0] .parentNode? this.first (). prevAll (). length: -1} , add: function (e, t) {retorna this.pushStack (S.uniqueSort (S.merge (this.get (), S (e, t)))))}, addBack: function (e) {retorna isso. add (null == e? this.prevObject: this.prevObject.filter (e))}}), S.each ({pai: função (e) {var t = e.parentNode; return t && 11! == t. nodeType? t: null}, parent: function (e) {return h (e, "parentNode")}, parentsUntil: function (e, t, n) {return h (e, "parentNode", n)},next: função (e) {retornar O (e, "próximo irmão")}, prev: função (e) {retornar O (e, "irmão anterior")}, nextAll: função (e) {retornar h (e, "próximo irmão) ")}, prevAll: function (e) {return h (e," previousSibling ")}, nextUntil: function (e, t, n) {return h (e," nextSibling ", n)}, prevUntil: function ( e, t, n) {return h (e, "previousSibling", n)}, irmãos: function (e) {return T ((e.parentNode || {}). firstChild, e)}, children: function ( e) {return T (e.firstChild)}, conteúdo: function (e) {return null! = e.contentDocument && r (e.contentDocument)? e.contentDocument: (A (e, "modelo") && (e = e .content || e), S.merge ([], e.childNodes))}}, função (r, i) {S.fn [r] = função (e, t) {var n = S.map ( isso, i, e); return "Até"! == r.slice (-5) && (t = e), t && "string" == tipo de t && (n = S.filter (t, n)), 1 <this.length &&(H [r] || S.uniqueSort (n), L.test (r) && n.reverse ()), this.pushStack (n)}}); var P = / [^ \ x20 \ t \ r \ n \ f] + / g; função R (e) {retorna e} função M (e) {lança e} função I (e, t, n, r) {var i; tenta {e && m (i = e.promise )? i.call (e) .done (t) .fail (n): e&&m (i = e.then)? i.call (e, t, n): t.apply (nulo 0, [e]). fatia (r))} captura (e) {n.apply (void 0, [e])}} S.Callbacks = function (r) {var e, n; r = "string" == typeof r? (e = r, n = {}, S.each (e.match (P) || [], função (e, t) {n [t] =! 0}), n): S.extend ({}, r); var i, t, o, a, s = [], u = [], l = -1, c = função () {para (a = a || r.once, o = i =! 0 ; u.length; l = -1) {t = u.shift (); while (++ l <s.length)! 1 === s [l] .apply (t [0], t [1] ) && r.stopOnFalse && (l = s.length, t =! 1)} r.memória || (t =! 1), i =! 1, a && (s = t? []: "")}, f = {add: function () {return s && (t &&! i && (l = s.length-1, u.push (t)), função n (e) {S.each (e, função (e, t) {m (t)? r.unique && f.tem (t) || s.push (t): t && t.length && "string"! == w (t) && n (t)})} (argumentos), t &&! i && c ()), this}, remove: function () {return S.each (argumentos, função (e, t) {var n; while (-1 <(n = S.inArray (t, s, n))) s.splice (n, 1), n <= l && l -}), this}, possui: function (e) {return e? -1 <S.inArray (e, s): 0 <s.length}, vazio: function () {return s && (s = []) this}, desativar: function () {retornar a = u = [], s = t = "", this}, disabled: function () {return! s}, lock: function () {return a = u = [], t || i || (s = t = ""), isto}, travado: function () {return !! a}, fireWith: function (e, t) {return a || (t = [e, (t = t || []). fatia? t.slice (): t], u.push (t), i || c ()), isto}, fire: function () {return f.fireCom (isso, argumentos), isso}, acionado: function () {return !! o}}; return f}, S.extend ({adiado: function (e) {var o = [["notify "," progress ", S.Callbacks (" memory "), S.Retornos de chamada ("memória"), 2], ["resolver", "concluído", S.Callbacks ("uma vez memória"), S.Callbacks ("uma vez memória"), 0, "resolvido"], ["rejeitar" , "falha", S.Callbacks ("uma vez memória"), S.Callbacks ("uma vez memória"), 1, "rejeitado"]], i = "pendente", a = {state: function () {return i }, sempre: function () {retorna s.done (argumentos). falha (argumentos), isso}, "captura": function (e) {retorna a.then (null, e)}, pipe: function () { var i = argumentos; retorna S.Deferido (função (r) {S.each (o, função (e, t) {var n = m (i [t [4]]) && i [t [4]]; s [t [1]] (function () {var e = n && n.apply (this, argumentos); e &&m (e.promise)? e.promise (). progress (r.notify) .done (r.resolve). falha (r.reject): r [t [0] + "With"] (isto, n? [e]: argumentos)})}), i = nulo}). promessa ()}, então: function (t , n, r) {var u = 0; função l (i, o, a,s) {função de retorno () {var n = isto, r = argumentos, e = função () {var e, t; if (! (i <u)) {if ((e = a.apply (n, r )) === o.promise ()) lança novo TypeError ("Auto-resolução escalável"); t = e && ("objeto" == tipo de e || "função" == tipo de e) && e então, m ( t)? s? t.call (e, l (u, o, R, s), l (u, o, M, s)) :( u ++, t.call (e, l (u, o, R , s), l (u, o, M, s), l (u, o, R, o.notifyWith))) :( a! == R && (n = void 0, r = [e]), ( s || o.resolveWith) (n, r))}}, t = s? e: function () {try {e ()} catch (e) {S.Deferred.exceptionHook && S.Deferred.exceptionHook (e, t .stackTrace), u <= i + 1 && (a! == M&& (n = void 0, r = [e]), o.rejectWith (n, r))}}; i? t () :( S. Deferred.getStackHook && (t.stackTrace = S.Deferred.getStackHook ()), C.setTimeout (t))}} retorna S.Deferred (função (e) {o [0] [3] .adicionar (l (0, e, m (r)? r: R, e.notifyWith)), o [1] [3] .add (l (0, e, m (t)? t: R)), o [2] [3 ] .add (l (0, e, m (n)? n: M))}). promessa ()}, promessa:function (e) {return null! = e? S.extend (e, a): a}}, s = {}; return S.each (o, função (e, t) {var n = t [2] , r = t [5]; a [t [1]] = n.add, r && n.add (função () {i = r}, o [3-e] [2] .disable, o [3-e ] [3] .disable, o [0] [2] .lock, o [0] [3] .lock), n.adicionar (t [3] .fire), s [t [0]] = function ( ) {return s [t [0] + "With"] (this === s? void 0: this, argumentos), this}, s [t [0] + "With"] = n.fireWith}), a.promise (s), e && e.call (s, s), s}, quando: function (e) {var n = argument.length, t = n, r = Array (t), i = s.call ( argumentos), o = S.Deferido (), a = função (t) {função de retorno (e) {r [t] = isto, i [t] = 1 <argumentos.length? s.call (argumentos): e , - n || o.resolveWith (r, i)}}; if (n <= 1 && (I (e, o.done (a (t)). resolve, o.reject,! n), "pendente "=== o.state () || m (i [t] && i [t] .then))) retorna o.then (); enquanto (t -) I (i [t], a (t) , o.reject); return o.promise ()}}); var W = / ^ (Eval | Internal | Range | Referência | Sintaxe | Type | URI) Erro $ /; S.Deferred.exceptionHook = função (e, t) {C.console && C.console.warn && e && W.test (e.name) && C.console.warn ("jQuery.Deferred exceção:" + e.message, e.stack, t)} , S.readyException = function (e) {C.setTimeout (function () {throw e})}; var F = S.Deferred (); função B () {E.removeEventListener ("DOMContentLoaded", B), C .removeEventListener ("load", B), S.ready ()} S.fn.ready = function (e) {retorna F.then (e) ["catch"] (function (e) {S.readyException (e )}), this}, S.extend ({isReady:! 1, readyWait: 1, ready: function (e) {(! 0 === e? - S.readyWait: S.isReady) || (S .isReady =! 0)! == e && 0 <- S.readyWait || F.resolveWith (E, [S])}}), S.ready.then = F.then, "complete" === E. readyState || "loading"! == E.readyState &&! E.documentElement.doScroll? C.setTimeout (S.ready) :( E.addEventListener ("DOMContentLoaded", B), C.addEventListener ("load", B)); var $ = function (e, t, n, r, i, o, a) {var s = 0, u = comprimento.l, = nulo == n; if ( "object" === w (n)) para (s em i =! 0, n) $ (e, t, s, n [s] ,! 0, o, a); caso contrário, se (void 0! = = r && (i =! 0, m (r) || (a =! 0), l && (a? (chamada (e, r), t = nula)) :( l = t, t = função (e , t, n) {retorna l.call (S (e), n)})), t)) para (; s <u; s ++) t (e [s], n, a? r: r.call (e [s], s, t (e [s], n))); return i? e: l? t.call (e): u? t (e [0], n): o}, _ = / ^ - ms - /, z = / - ([az]) / g; função U (e, t) {retornar t.toUpperCase ()} função X (e) {retornar e.replace (_, "ms - "). replace (z, U)} var V = função (e) {return 1 === e.nodeType || 9 === e.nodeType ||! + e.nodeType}; função G () { this.expando = S.expando + G.uid ++} G.uid = 1, G.prototype = {cache: function (e) {var t = e [this.expando]; return t || (t = Object.create (nulo), V (e) && (e.nodeType? e [this.expando] = t: Object.defineProperty (e, this.expando, {value: t, configurável:! 0}))), t}, set: function (e, t,n) {var r, i = this.cache (e); if ("string" == tipo de t) i [X (t)] = n; mais para (r em t) i [X (r)] = t [r]; return i}, get: function (e, t) {return void 0 === t? this.cache (e): e [this.expando] && e [this.expando] [X (t) ]}, acesso: função (e, t, n) {return void 0 === t || t && "string" == tipo de t && void 0 === n? this.get (e, t) :( this.set (e, t, n), void 0! == n? n: t)}, remove: function (e, t) {var n, r = e [this.expando]; if (void 0! == r ) {if (void 0! == t) {n = (t = Array.isArray (t)? t.map (X) :( t = X (t)) em r? [t]: t.match ( P) || []). Length; while (n -) delete r [t [n]]} (void 0 === t || S.isEmptyObject (r)) && (e.nodeType? E [this .expando] = void 0: delete e [this.expando])}}, hasData: function (e) {var t = e [this.expando]; return void 0! == t && S.isEmptyObject (t)} }; var Y = novo G, Q = novo G, J = / ^ (?: \ {[\ w \ W] * \} | \ [[\ w \ W] * \]) $ /, K = / [AZ] / g; função Z (e, t, n) {var r, i; if (void 0 === n && 1 === e.nodeType) if (r = "data - "+ t.replace (K," - $ & "). toLowerCase ()," string "== typeof (n = e.getAttribute (r))) {try {n =" true "=== ( i = n) || "false"! == i && ("null" === i? null: i === + i + ""? + i: J.test (i)? JSON.parse (i): i)} catch (e) {} Q.set (e, t, n)} else n = void 0; return n} S.extend ({hasData: function (e) {return Q.hasData (e) || Y.hasData (e)}, data: function (e, t, n) {retornar Q.access (e, t, n)}, removeData: function (e, t) {Q.remove (e, t)} , _dados: função (e, t, n) {retorna Y.access (e, t, n)}, _ removeData: função (e, t) {Y.remove (e, t)}}), S.fn. estender ({dados: função (n, e) {var t, r, i, o = isto [0], a = o && o.atributos; if (void 0 === n) {if (this.length && (i = Q.get (o), 1 === o.nodeType &&! Y.get (o, "hasDataAttrs"))) {t = a.length; while (t -) a [t] && 0 === (r = a [t] .name) .indexOf ("data -") && (r = X (r.slice (5)), Z (o, r, i [r])); Y.set (o, "hasDataAttrs ",! 0)} retornar i} retornar" objeto "== tipo de n? this.each (function () {Q.set (este, n)}): $ (isso, função (e) {var t; Se (o && void 0 === e) retornar nulo 0! == (t = Q.get (o, n))? t: nulo 0! == (t = Z (o, n))? t: nulo 0 ; this.each (function () {Q.set (this, n, e)})}, null, e, 1 <argument.length, null,! 0)}, removeData: function (e) {retorna isso. each (function () {Q.remove (this, e)})}}), S.extend ({fila: function (e, t, n) {var r; se (e) retornar t = (t || "fx") + "fila", r = Y.get (e, t), n && (! r || Array.isArray (n)? r = Y.access (e, t, S.makeArray (n)) : r.push (n)), r || []}, desenfileirar: função (e, t) {t = t || "fx"; var n = S.queue (e, t), r = n. length, i = n.shift (), o = S._queueHooks (e, t); "inprogress" === i && (i = n.shift (), r -), i && ("fx" === t && n.unshift ("inprogress"), exclua o.stop, i.call (e, function () {S.dequeue (e, t)}, o)) ,! r && o && o.empty.fire ()}, _ queueHooks: function (e, t) {var n = t + "queueHooks"; retorna Y.get (e, n) || Y.access (e, n, {vazio: S. Retornos de chamada ("uma vez memória"). Add (function () {Y.remove (e, [t + "fila", n])})})}})), S.fn.extend ({fila: function (t, n) {var e = 2; return "string"! = tipo de t && (n = t, t = "fx", e -), argumentos.length <e? S.queue (this [0], t): void 0 === n? this: this.each (function () {var e = S.queue (this, t, n); S._queueHooks (this, t), "fx" === && "inprogress" ! == e [0] && S.quequeue (this, t)})}, desenfileire: function (e) {retorne this.each (function () {S.quequeue (this, e)})}, clearQueue: function (e) {retorna this.queue (e || "fx", [])}, promessa: função (e, t) {var n, r = 1, i = S.Deferred (), o = this, a = this.length, s = function () {- r || i.resolveWith (o, [o])}; "string"! = tipo de e && (t = e, e = nulo 0), e = e | | "fx";while (a -) (n = Y.get (o [a], e + "queueHooks")) && n.empty && (r ++, n.empty.add (s)); return s (), i.promise (t )}}); var ee = / [+ -]? (?: \ d * \. |) \ d + (?: [eE] [+ -]? \ d + |) /. source, te = new RegExp ( "^ (?: ([+ -]) = |) (" + ee + ") ([az%] *) $", "i"), ne = ["Superior", "Direita", "Inferior", "Esquerda"], re = E.documentElement, ie = função (e) {retorna S.contains (e.ownerDocument, e)}, oe = {compor:! 0}; re.getRootNode && (ou seja, = function (e) {return S.contains (e.ownerDocument, e) || e.getRootNode (oe) === e.ownerDocument}); var ae = function (e, t) {return "none" === (e = t || e) .style.display || "" === e.style.display && ie (e) && "none" === S.css (e, "exibição")}; function se (e, t, n , r) {var i, o, a = 20, s = r? function () {retorna r.cur ()}: function () {retorna S.css (e, t, "")}, u = s (), l = n && n [3] || (S.cssNumber [t]? "": "px"), c = e.nodeType && (S.cssNumber [t] || "px"! == l && + u) && te.exec (S.css (e, t)) ; if (c && c [3]! == l) {u / = 2, l = l || c [3], c = + u || 1; enquanto (a -) S.style (e, t, c + l), (1-o) * (1- (o = s () / u || .5)) <= 0 && (a = 0), c / = o; c * = 2, estilo S. (e, t, c + l), n = n || []} retorna n && (c = + c || + u || 0, i = n [1]? c + (n [1] +1) * n [2]: + n [2], r && (r.unit = l, r.start = c, r.end = i)), i} var ue = {}; função le (e, t) {para (var n, r, i, o, a, s, u, l = [], c = 0, f = comprimento.c; c <f; c ++) (r = e [c]). style && (n = r.style.display, t? ("nenhum" === n && (l [c] = Y.get (r, "exibição") || nulo, l [c] || (r.style.display = " "))," "=== r.style.display && ae (r) && (l [c] = (u = a = o = vazio 0, a = (i = r) .ownerDocument, s = i.nodeName, (u = ue [s]) || (o = a.body.appendChild (a.createElement (s)), u = S.css (o, "exibição"), o.parentNode.removeChild (o),"none" === u && (u = "bloco"), ue [s] = u)))): "none"! == n && (l [c] = "none", Y.set (r, " display ", n))); para (c = 0; c <f; c ++) null! = l [c] && (e [c] .style.display = l [c]); return e} S.fn .extend ({show: function () {return le (this,! 0)}, hide: function () {return le (this)}, alterna: function (e) {return "boolean" == typeof e? e Este é um exemplo de um exemplo de código que pode ser usado para definir o valor de uma variável em uma variável, que é o valor da variável. ce, fe, pe = / ^ (?: caixa de seleção | radio) $ / i, de = / <([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] *) / i, ele = / ^ $ | ^ módulo $ | \ / (?: java | ecma) script / i; ce = E.createDocumentFragment (). appendChild (E.createElement ("div")), (fe = E.createElement ( "entrada")). setAttribute ("tipo", "rádio"), fe.setAttribute ("marcado", "marcado"), fe.setAttribute ("nome", "t"), ce.appendChild (fe),y.checkClone = ce.cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, ce.innerHTML = "<textarea> x </textarea>", y.noCloneChecked = !! ce.cloneNode (! 0) .lastChild.defaultValue, ce.innerHTML = "<opção> </option>", y.option = !! ce.lastChild; var ge = {thead: [1, "<table>", "</table>" ], col: [2, "<table> <colgroup>", "</colgroup> </table>"], tr: [2, "<table> <tbody>", "</tbody> </ table > "], td: [3," <table> <tbody> <tr> "," </tr> </tbody> </table> "], _ padrão: [0," "," "]}; função ve (e, t) {var n; return n = "indefinido"! = tipo de e.getElementsByTagName? e.getElementsByTagName (t || "*"): "indefinido"! = tipo de e.querySelectorAll? e.querySelectorAll (t || "*"): [], nulo 0 === t || t && A (e, t)? S.merge ([e], n): n} função ye (e, t) {para (var n = 0, r = e.length; n <r; n ++) Y.set (e [n], "globalEval",! t || Y.get (t [n], "globalEval"))} ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td, y.option || (ge.optgroup = ge.option = [1, "<selecione vários = 'múltiplo'> "," </select> "]); var me = / <| & #? \ w +; /; função xe (e, t, n, r, i) {for (var o, a, s, u, l, c, f = t.createDocumentFragment (), p = [], d = 0, h = comprimento.d; d <h; d ++) if ((o = e [d]) || 0 === o) if ("objeto" === w (o)) S.merge (p, o.nodeType? [o]: o); caso contrário, se (me.test (o)) {a = a | | f.appendChild (t.createElement ("div")), s = (de.exec (o) || ["", ""]) [1] .toLowerCase (), u = ge [s] || ge._default, a.innerHTML = u [1] + S.htmlPrefilter (o) + u [2], c = u [0]; enquanto (c -) a = a.lastChild; S.merge (p, a.childNodes), (a = f.firstChild) .textContent = ""} else p.push (t.createTextNode (o)); f.textContent = "", d = 0; while (o = p [d ++]) if (r && - 1 <S.inArray (o, r)) i && i.push (o); caso contrário, se (l = ie (o), a = ve (f.appendChild (o), "script"), l && ye (a), n) {c = 0 ; while (o = a [c ++]) he.test (o.type || "") && n.push (o)} retornar f} var ser = / ^ tecla /, nós = / ^ (?: mouse | ponteiro | contextmenu | arrastar | soltar) | clicar em /, Te = / ^ ([^.] *) (?: \. (. +) |) /; função Ce () {return! 0} função Ee () {return ! 1} function Se (e, t) {return e === function () {try {return E.activeElement} catch (e) {}} () == ("focus" === t)} function ke (e, t, n, r, i, o) {var a, s; if ("objeto" == tipo de t) {para (s em "string"! = tipo de n && (r = r || n, n = void 0), t) ke (e, s, n, r, t [s], o); retorna e} if (null == r && null == i? (i = n, r = n = void 0) : null == i && ("string" == tipo de n? (i = r, r = nulo 0) :( i = r, r = n, n = nulo 0)) ,!1 === i) i = Ee; caso contrário, se (! I) retorna e; retorna 1 === o && (a = i, (i = função (e) {retorna S (). Off (e), a. aplicar (isso, argumentos)}). guid = a.guid || (a.guid = S.guid ++)), e.each (function () {S.event.add (this, t, i, r, n )})} function Ae (e, i, o) {o? (Y.set (e, i,! 1), S.event.add (e, i, {namespace:! 1, manipulador: function (e ) {var t, n, r = Y.get (this, i); if (1 & e.isTrigger && this [i]) {if (r.length) (S.event.special [i] || {}). delegateType && e .stopPropagation (); caso contrário, se (r = s.call (argumentos), Y.set (this, i, r), t = o (this, i), this [i] (), r! == (n = Y.get (this, i)) || t? Y.set (this, i,! 1): n = {}, r! == n) retorna e.stopImmediatePropagation (), e.preventDefault (), n.valor} else r.length && (Y.set (isto, i, {valor: S.event.trigger (S.extend (r [0], S.Event.prototype), r.slice (1), este )}), e.stopImmediatePropagation ())}})): void 0 === Y.get (e, i) && S.event.add (e, i, Ce)} S.event = {global: {} , add: function (t, e, n, r, i) {var o, a, s, u, l, c,f, p, d, h, g, v = Y.get (t); if (V (t)) {n.handler && (n = (o = n) .handler, i = o.seletor), i && S. find.matchesSelector (re, i), n.guid || (n.guid = S.guid ++), (u = v.eventos) || (u = v.events = Object.create (null)), (a = v.handle) || (a = v.handle = function (e) {return "undefined"! = tipo de S&& S.event.triggered! == e.type? S.event.dispatch.apply (t, argumentos) : void 0}), l = (e = (e || ""). match (P) || [""]). length; while (l -) d = g = (s = Te.exec ( e [l]) || []) [1], h = (s [2] || ""). split ("."). sort (), d && (f = S.event.special [d] || {}, d = (i? f.delegateType: f.bindType) || d, f = S.event.special [d] || {}, c = S.extend ({type: d, origType: g, dados: r, manipulador: n, guia: n.guid, seletor: i, needsContext: i && S.expr.match.needsContext.test (i), namespace: h.join (".")}, o), (p = u [d]) || ((p = u [d] = []). delegateCount = 0, f.setup &&! 1! == f.setup.call (t, r, h, a) | | t.addEventListener && t.addEventListener (d, a)), f.add && (f.add.call (t, c), c.handler.guid || (c.handler.guid = n.guid)), i? p.splice (p.delegateCount ++, 0, c): p.push (c), S.event.global [d] =! 0)}}, remove: function (e, t, n, r, i) {var o, (a) () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () t = (t || ""). match (P) || [""]). length; while (l -) if (d = g = (s = Te.exec (t [l]) || []) [1], h = (s [2] || ""). Split ("."). Sort (), d) {f = S.event.especial [d] || {}, p = u [d = (r? f.delegateType: f.bindType) || d] || [], s = s [2] && new RegExp ("(^ | \\.)" + h.join ("\ \. (?:. * \\. |) ") +" (\\. | $) "), a = o = p.length; enquanto (o -) c = p [o] ,! i && g! == c.origType || n && n.guid! == c.guid || s &&! s.test (c.namespace) || r && r! == c.seletor && ("**"! == r ||! c .selector) || (p.splice (o, 1), c.selector && p.delegateCount -, f.remove && f.remove.call (e, c)); a &&! p.length && (f.teardown &&! 1! == f.teardown.call (e, h, v.handle) || S. removeEvent (e, d, v.handle), exclua u [d])} else para (d em u) S.event.remove (e, d + t [l], n, r,! 0); S. isEmptyObject (u) && Y.remove (e, "manipule eventos")}}, dispatch: function (e) {var t, n, r, i, o, a, s = new Array (argumentos. comprimento), u = S.event.fix (e), l = (Y.get (isto, "eventos") || Objeto.criar (nulo)) [u.type] || [], c = S.event.special [u .type] || {}; for (s [0] = u, t = 1; t <argumentos.length; t ++) s [t] = argumentos [t]; if (u.delegateTarget = this,! c. preDispatch ||! 1! == c.preDispatch.call (this, u)) {a = S.event.handlers.call (this, u, l), t = 0; while ((i = a [t ++] ) &&! u.isPropagationStopped ()) {u.currentTarget = i.elem, n = 0; while ((o = i.handlers [n ++]) &&! u.isImmediatePropagationStopped ()) u.rnamespace &&! 1! == o.namespace &&! u.rnamespace.test (o.namespace) || (u.handleObj = o, u.data = o.data, void 0! == (r = ((S.event.special [o.origType] || {}))) .handle || o.handler) .apply (i.elem, s)) && 1 === (u.result = r) && (u.preventDefault (), u.stopPropagation ()))} return c. postDispatch && c.postDispatch.call (this, u), u.result}}, manipuladores: function (e, t) {var n, r, i, o, a, s = [], u = t.delegateCount, l = e.target; if (u && l.nodeType &&! ("click" === e.type && 1 <= e.button)) para (; l! == this; l = l.parentNode || this) if (1 == = l.nodeType && ("clique"! == e.type ||! 0! == l.disabled)) {for (o = [], a = {}, n = 0; n <u; n ++) 0 === a [i = (r = t [n]). Seletor + ""] && (a [i] = r.needContext? -1 <S (i, this) .index (l): S.find (i, this, null, [l]). length), a [i] && o.push (r); o.length && s.push ({elem: l, manipuladores: o})} retornam l = this, u < t.length && s.push ({elem: l, manipuladores: t.fatia (u)}), s}, addProp: função (t, e) {Object.defineProperty (S.Event.prototype, t, {enumerável:! 0, configurável:! 0, get: m (e)? function () {if (this.originalEvent) retorna e (this.originalEvent)}: function () {if (this.originalEvent) retorna this.originalEvent [t]}, define: function (e) {Object.defineProperty (this, t, {enumerável:! 0, configurável:! 0, gravável:! 0, valor: e})}})}, correção: função (e) {return e [S.expando]? e: new S.Event ( e)}, especial: {load: {noBubble:! 0}, clique em: {setup: function (e) {var t = this || e; retorne pe.test (t.type) && t.click && A (t, " input ") && Ae (t," clique ", Ce) ,! 1}, trigger: function (e) {var t = this || e; retorna pe.test (t.type) && t.click && A (t," input ") && Ae (t," clique ") ,! 0}, _ padrão: function (e) {var t = e.target; retorna pe.test (t.type) && t.click && A (t," input ") && Y. get (t ",clique em ") || A (t," a ")}}, antes da transferência: {postDispatch: function (e) {void 0! == e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)}}} }, S.removeEvent = function (e, t, n) {e.removeEventListener && e.removeEventListener (t, n)}, S.Event = function (e, t) {if (! (This instance of S.Event)) return new S.Event (e, t); e && e.type? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented &&! 1 == = e.returnValue? ): this.type = e, t && S.extend (this, t), this.timeStamp = e && e.timeStamp || Date.now (), this [S.expando] =! 0}, S.Event.prototype = { construtor: S.Event, isDefaultPrevented: Ee, isPropagationStopped: Ee,isImmediatePropagationStopped: Ee, isSimulated:! 1, preventDefault: function () {var e = this.originalEvent; this.isDefaultPrevented = Ce, e && this.isSimulated && e.preventDefault ()}, stopPropagation: function () {var e = this. originalEvent; this.isPropagationStopped = Ce, e && this.isSimulated && e.stopPropagation ()}, stopImmediatePropagation: function () {var e = this.originalEvent; stopPropagation ()}}, S.each ({altKey:! 0, bolhas:! 0, cancelável:! 0, alterouTouches:! 0, ctrlKey:! 0, detalhe:! 0, eventPhase:! 0, metaKey:! 0 , páginaX:! 0, páginaY:! 0, shiftKey:! 0, visualização:! 0, "char":! 0, código:! 0, charCode:! 0, chave:! 0, keyCode:! 0, botão: ! 0, botões:! 0, clientX:! 0, clientY:! 0, offsetX:! 0, offsetY:! 0, pointerId:! 0, pointerType:! 0, screenX:! 0, screenY:! 0, targetTouches: ! 0, toElement:! 0, toca:! 0, que: function (e) {var t = e.button; return null == e.que &&teste (e.type)? Null! = E.charCode? E.charCode: e. keyCode:! e.which && void 0! == t && we.test (e.type)? 1 & t? 1: 2 & t? 3: 4 & t? 2: 0: e.qual}}, S.event.addProp), S.each ( {focus: "focusin", blur: "focusout"}, função (e, t) {S.event.special [e] = {setup: function () {retorna Ae (isto, e, Se) ,! 1} , trigger: function () {return Ae (this, e) ,! 0}, delegateType: t}}), S.each ({mouseenter: "mouseover", mouseleave: "mouseout", ponteiro: "ponteiro", ponteiro) : "apontador"}, função (e, i) {S.event.special [e] = {delegateType: i, bindType: i, identificador: function (e) {var t, n = e.relatedTarget, r = e .handleObj== t && we.test (e.type)? 1 & t? 1: 2 & t? 3: 4 & t? 2: 0: e.qual}}, S.event.addProp), S.each ({focus: "focusin", blur : "focusout"}, função (e, t) {S.event.special [e] = {setup: function () {return Ae (this, e, Se) ,! 1}, trigger: function () {return Ae (this, e) ,! 0}, delegateType: t}}), S.each ({mouseenter: "mouseover", mouseleave: "mouseout", ponteiro: "ponteiro", ponteiro: "ponteiro"), function ( e, i) {S.event.special [e] = {delegateType: i, bindType: i, handle: function (e) {var t, n = e.relatedTarget, r = e.handleObj== t && we.test (e.type)? 1 & t? 1: 2 & t? 3: 4 & t? 2: 0: e.qual}}, S.event.addProp), S.each ({focus: "focusin", blur : "focusout"}, função (e, t) {S.event.special [e] = {setup: function () {return Ae (this, e, Se) ,! 1}, trigger: function () {return Ae (this, e) ,! 0}, delegateType: t}}), S.each ({mouseenter: "mouseover", mouseleave: "mouseout", ponteiro: "ponteiro", ponteiro: "ponteiro"), function ( e, i) {S.event.special [e] = {delegateType: i, bindType: i, handle: function (e) {var t, n = e.relatedTarget, r = e.handleObjmouseover ", mouseleave:" mouseout ", ponteiro:" ponteiro ", ponteiro:" ponteiro "}, função (e, i) {S.event.special [e] = {delegateType: i, bindType: i, handle: function (e) {var t, n = e.relatedTarget, r = e.handleObjmouseover ", mouseleave:" mouseout ", ponteiro:" ponteiro ", ponteiro:" ponteiro "}, função (e, i) {S.event.special [e] = {delegateType: i, bindType: i, handle: function (e) {var t, n = e.relatedTarget, r = e.handleObj; return n && (n === this || S.contains (this, n)) || (e.type = r.origType, t = r.handler.apply (isto, argumentos), e.type = i) , t}}}), S.fn.extend ({on: function (e, t, n, r) {retorna ke (this, e, t, n, r)}, um: function (e, t, n, r) {return ke (isto, e, t, n, r, 1)}, off: function (e, t, n) {var r, i; if (e && e.preventDefault && e.handleObj) return r = e .handleObj, S (e.delegateTarget) .off (r.namespace? r.origType + "." + r.namespace: r.origType, r.selector, r.handler), this; if ("object" == typeof e) {for (i in e) this.off (i, t, e [i]); retorne isso} return! 1! == t && "function"! = typeof t || (n = t, t = void 0) ,! 1 === n && (n = Ee), this.each (function () {S.event.remove (this, e, n, t)})}}); var Ne = / <script | <estilo | <link / i, De = / marcado \ s * (?: [^ =] | = \ s *. verificado.) / i, je = / ^ \ s * <! (?: \ [CDATA \ [| -) | (?: \] \] | -)> \ s * $ / g; função qe (e, t) {retorna A (e, "tabela") && A (11! == t.nodeType? t: t.firstChild, "tr") && S (e) .children ("tbody") [0] || e} função Le (e) {return e.type = (null! == e.getAttribute ( "type")) + "/" + e.type, e} função He (e) {return "true /" === (e.type || ""). slice (0,5)? e.type = e.type.slice (5): e.removeAttribute ("type"), e} função Oe (e, t) {var n, r, i, o, a, s; if (1 === t. nodeType) {if (Y.hasData (e) && (s = Y.get (e) .events)) para (i em Y.remove (t, "manipular eventos"), s) para (n = 0, r = s [i] .length; n <r; n ++) S.event.add (t, i, s [i] [n]); Q.hasData (e) && (o = Q.access (e), a = S. extender ({}, o), Q.set (t, a))}} função Pe (n, r, i, o) {r = g (r); var e, t, a, s , u, l, c = 0, f = comprimento n, p = f-1, d = r [0], h = m (d); se (h || 1 <f && "string" == tipo de d && ! y.checkClone && De.test (d)) retorna n.each (função (e) {var t = n.eq (e); h && (r [0] = d.call (this, e, t.html ()) )), Pe (t, r, i, o)});Se (f && (t = (e = xe (r, n [0] .Documento proprietário,! 1, n, o))). firstChild, 1 === e.childNodes.length && (e = t), t || o )) {for (s = (a = S.map (ve (e, "script"), Le)). length; c <f; c ++) u = e, c! == p && (u = S.clone (u,! 0,! 0), s && S.merge (a, ve (u, "script"))), i.call (n [c], u, c); if (s) para (l = a [a.length-1] .ownerDocument, S.map (a, He), c = 0; c <s; c ++) u = a [c], he.test (u.type || "") &&! Y.access (u, "globalEval") && S. contém (l, u) && (u.src && "módulo"! == (u.type || ""). ToLowerCase ()? S._evalUrl &&! U.noModule && S ._evalUrl (u.src, {nonce: u.nonce || u.getAttribute ("nonce")}), l): b (u.textContent.replace (je, ""), u, l))} return n } função Re (e, t, n) {para (var r, i = t? S.filtro (t, e): e, o = 0; nulo! = (r = i [o]); o ++) n || 1! == r.nodeType || S.cleanData (ve (r)), r.parentNode && (n && ou seja (r) &&você (ve (r, "script")), r.parentNode.removeChild (r)); return e} S.extend ({htmlPrefilter: function (e) {return e}, clone: ​​function (e, t, n ) {var r, i, o, a, s, u, l, c = e.cloneNode (! 0), f = ie (e); if (! (y.noCloneChecked || 1! == e.nodeType && 11 ! == e.nodeType || S.isXMLDoc (e))) para (a = ve (c), r = 0, i = (o = ve (e)). length; r <i; r ++) s = o [r], u = a [r], nulo 0, "entrada" === (l = u.nodeName.toLowerCase ()) && pe.test (s.type)? u.checked = s.checked: " input "! == l &&" textarea "! == l || (u.defaultValue = s.defaultValue); if (t) if (n) para (o = o || ve (e), a = a || ve (c), r = 0, i = o.length; r <i; r ++) Oe (o [r], a [r]); caso contrário Oe (e, c); return 0 <(a = ve ( c, "script")). length && ye (a,! f && ve (e, "script")), c}, cleanData: function (e) {for (var t, n, r, i = S.event.special, o = 0; void 0! == (n = e [o]); o ++) if (V (n)) {if (t = n [Y.expando]) {if (t.events) for (r in t.events) i [r]? S.event.remove (n,r): S.removeEvent (n, r, t.handle); n [Y.expando] = nulo 0} n [Q.expando] && (n [Q.expando] = nulo 0)}}}), S .fn.extend ({desanexar: função (e) {retornar Re (isto, e,! 0)}, remover: função (e) {retornar Re (este, e)}, texto: função (e) {retornar $ (this, function (e) {return void 0 === e? S.text (this): this.empty (). each (function () {1! == this.nodeType && 11! == this.nodeType && 9! = = this.nodeType || (this.textContent = e)})}, null, e, argument.length)}, anexa: function () {retorna Pe (isso, argumentos, function (e) {1! == this .nodeType && 11! == this.nodeType && 9! == this.nodeType || qe (isso, e) .appendChild (e)})}, prefixo: function () {retorna Pe (isso, argumentos, função (e) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var t = qe (this, e); t.insertBefore (e, t.firstChild)}} )}, before: function () {return Pe (this, argumentos, função (e) {this.parentNode && this.parentNode.insertBefore (e,this)})}, after: function () {return Pe (this, argumentos, function (e) {this.parentNode && this.parentNode.insertBefore (e, this.nextSibling)})}, vazio: function () {for ( var e, t = 0; null! = (e = this [t]); t ++) 1 === e.nodeType && (S.cleanData (ve (e,! 1)), e.textContent = ""); retorne}, clone: ​​function (e, t) {retorne e = null! = e && e, t = null == t? e: t, this.map (function () {retorne S.clone (this, e, t )})}, html: function (e) {return $ (this, function (e) {var t = this [0] || {}, n = 0, r = this.length; if (void 0 == = e && 1 === t.nodeType) retorna t.innerHTML; if ("string" == tipo de e &&! Ne.test (e) &&! ge [(de.exec (e) || ["", ""]] ) [1] .toLowerCase ()]) {e = S.htmlPrefilter (e); tente {for (; n <r; n ++) 1 === (t = este [n] || {}). NodeType && ( S.cleanData (ve (t,! 1)), t.innerHTML = e); t = 0} catch (e) {}} t && this.empty (). Append (e)}, null, e, argument.length )},substituir com:function () {var n = []; return Pe (this, argumentos, função (e) {var t = this.parentNode; S.inArray (this, n) <0 && (S.cleanData (ve (this)), t && t.replaceChild (e, isto)), n)}}), S.each ({appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith "}, função (e, a) {S.fn [e] = função (e) {para (var t, n = [], r = S (e), i = r.length-1, o = 0 ; o <= i; o ++) t = o === i? this: this.clone (! 0), S (r [o]) [a] (t), u.apply (n, t.get ( )); return this.pushStack (n)}}); var Me = new RegExp ("^ (" + ee + ") (?! px) [az%] + $", "i"), ie = function ( e) {var t = e.ownerDocument.defaultView; retorna t && t.opener || (t = C), t.getComputedStyle (e)}, We = function (e, t, n) {var r, i, o = {}; para (i in t) o [i] = e.style [i], e.style [i] = t [i]; para (i em r = n. chamada (e), t) e. estilo [i] = o [i]; retorna r}, Fe = new RegExp (ne.join ("|"),"i"); function Be (e, t, n) {var r, i, o, a, s = e.style; return (n = n || Ie (e)) && (""! == ( a = n.getPropertyValue (t) || n [t]) || ie (e) || (a = S.style (e, t)) ,! teste (t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0! == a? a + "": a} função $ e (e, t) {return {get: function () {if (! e () ) return (this.get = t) .apply (this, argument); delete this.get}}}! function () {function e () {if (l) {u.style.cssText = "position: absolute; esquerda: -11111px; largura: 60px; margem superior: 1px; preenchimento: 0; borda: 0 ", l.style.cssText =" posição: relativa; exibição: bloco; tamanho da caixa: borda-caixa; estouro: rolagem ; margin: auto; border: 1px; padding: 1px; width: 60%; top: 1% ", re.appendChild (u) .appendChild (l); var e = C.getComputedStyle (l); n =" 1 % "! == e.top, s = 12 === t (e.marginLeft), l.style.a direita = "60%", o = 36 === t (direita), r = 36 === t (largura e), l.style.posicao "absoluta", i = 12 === t (l.offsetWidth / 3), re.removeChild (u), l = null}} função t (e) {retorna Math.round (parseFloat (e))} var n, r, i , o, a, s, u = E.criarElement ("div"), l = E.criarElement ("div"); l.style && (l.style.backgroundClip = "caixa de conteúdo", l.cloneNode (! 0) .style.backgroundClip = "", y.clearCloneStyle = "caixa de conteúdo" === l.style.backgroundClip, S.extend (y, {boxSizingReliable: function () {retorno e (), r}, pixelBoxStyles : function () {return e (), o}, pixelPosition: function () {return e (), n}, reliableMarginLeft: function () {return e (), s}, scrollboxSize: function () {return e ( ), i}, reliableTrDimensions: function () {var e, t, n, r; return null == a && (e = E.createElement ("tabela"), t = E.createElement ("tr"), n = E.createElement ("div"), e.style.cssText = "posição: absoluta; esquerda: -11111px", t.style.height = "1px", n.style.height = "9px", re.appendChild (e) .appendChild (t) .appendChild (n), r = C.getComputedStyle (t), a = 3 <parseInt (r.height), re.removeChild (e)), a}}))} (); var _e = ["Webkit", "Moz", "ms"], ze = E.createElement ("div"). Style, Ue = {}; função Xe (e) {var t = S.cssProps [e] || Ue [e]; return t || (e em ze? E: Ue [e] = função (e) {var t = e [0] .toUpperCase () + e.slice (1), n ​​= _e.length ; while (n -) if ((e = _e [n] + t) em ze) retorna e} (e) || e)} var Ve = / ^ (nenhum | tabela (?! - c [ea] ). +) /, Ge = / ^ - /, Ye = {posição: "absoluta", visibilidade: "oculta", exibição: "bloco"}, Qe = {letterSpacing: "0", fontWeight: "400" }; função Je (e, t, n) {var r = te.exec (t); retorno r? Math.max (0, r [2] - (n || 0)) + (r [3] | | "px"):t} função Ke (e, t, n, r, i, o) {var a = "width" === t? 1: 0, s = 0, u = 0; if (n === (r? "borda": "conteúdo")) retorna 0; para (; a <4; a + = 2) "margem" === n && (u + = S.css (e, n + ne [a] ,! 0, i )), r? ("conteúdo" === n && (u- = S.css (e, "preenchimento" + ne [a] ,! 0, i)), "margem"! == n && (u- = S.css (e, "borda" + ne [a] + "Largura",! 0, i))) :( u + = S.css (e, "preenchimento" + ne [a] ,! 0, i) , "padding"! == n? u + = S.css (e, "borda" + ne [a] + "Largura",! 0, i): s + = S.css (e, "borda" + ne [ a] + "Largura",! 0, i)); return! r && 0 <= o && (u + = Math.max (0, Math.ceil (e ["offset" + t [0] .toUpperCase () + t. fatia (1)] - ous-.5)) || 0), u} função Ze (e, t, n) {var r = Ie (e), i = (! y.boxSizingReliable () || n) && "border-box" === S.css (e, "boxSizing",! 1, r), o = i, a = Seja (e, t, r), s = "deslocamento "+ t [0] .toUpperCase () + t.slice (1); if (Me.test (a)) {if (! n) retorna um; a =" auto "} retorna (! y.boxSizingReliable ( ) && i ||! y.reliableTrDimensions () && A (e, "tr") || "auto" === a ||! parseFloat (a) && "inline" === S.css (e, "display" ,! 1, r)) && e.getClientRects (). Length && (i = "border-box" === S.css (e, "boxSizing",! 1, r), (o = s em e) && ( a = e [s])), (a = parseFloat (a) || 0) + Ke (e, t, n || (i? "borda": "conteúdo"), o, r, a) + " px "} função et (e, t, n, r, i) {retornar novo et.prototype.init (e, t, n, r, i)} S.extend ({cssHooks: {opacidade: {get: function (e, t) {if (t) {var n = Be (e, "opacidade"); return "" === n? "1": n}}}}, cssNumber: {animationIterationCount:! 0, columnCount :! 0, fillOpacity:! 0, flexGrow:! 0, flexShrink:! 0, fontWeight:! 0, gridArea:! 0, gridColumn:! 0,gridColumnEnd:! 0, gridColumnStart:! 0, gridRow:! 0, gridRowEnd:! 0, gridRowStart:! 0, lineHeight:! 0, opacidade:! 0, order:! 0, órfãos:! 0, viúvas:! 0, zIndex:! 0, zoom:! 0}, cssProps: {}, estilo: função (e, t, n, r) {if (e && 3! == e.nodeType && 8! == e.nodeType && e.style) {var i , o, a, s = X (t), u = teste.t (t), l = e.style; se (u || (t = Xe (s)), a = S.cssHooks [t] | | S.cssHooks [s], void 0 === n) retorna um && "get" em um && void 0! == (i = a.get (e,! 1, r))? I: l [t]; " string "=== (o = tipo de n) && (i = te.exec (n)) && i [1] && (n = se (e, t, i), o =" número "), nulo! = n && n == n && ("número"! == o || u || (n + = i && i [3] || (S.cssNumber [s]? "": "px")), y.clearCloneStyle || ""! == n || 0! == t.indexOf ("background") || (l [t] = "herdar"), um & "conjunto" em um && void 0 === (n = a.set (e, n , r)) || (u? l.setProperty (t, n): l [t] = n))}}, css: function (e, t, n, r) {var i, o, a, s = X (t); return Ge.test ( t) || (t = Xe (s)), (a = S.cssHooks [t] || S.cssHooks [s]) && "get" em um && (i = a.get (e,! 0, n )), void 0 === i && (i = Be (e, t, r)), "normal" === i && em Qe && (i = Qe [t]), "" === n || n? (o = parseFloat (i) ,! 0 === n || isFinite (o)? o || 0: i): i}}), S.each (["height", "width"], function ( e, u) {S.cssHooks [u] = {get: function (e, t, n) {se (t) retornar! Ve.test (S.css (e, "exibição")) || e.getClientRects () .length && e.getBoundingClientRect (). width? Ze (e, u, n): Nós (e, Ye, function () {retorna Ze (e, u, n)})}, definimos: function (e, t , n) {var r, i = Ie (e), o =! y.scrollboxSize () && "absolute" === posição i, a = (o || n) && "border-box" === S.css (e, "boxSizing",! 1, i), s = n? Ke (e, u, n, a, i): 0; retorne um && o && (s- = Math.ceil (e ["offset "+ u [0] .toUpperCase () + u.slice (1)] - parseFloat (i [u]) - Ke (e, u," borda ",! 1, i) -. 5)), s && (r = te.exec (t)) && "px"! == (r [3] || "px") && (e.style [u] = t, t = S.css (e, u)) , Je (0, t, s)}}}), S.cssHooks.marginLeft = $ e (y.reliableMarginLeft, função (e, t) {if (t) return (parseFloat (Be (e, "marginLeft")) ) || e.getBoundingClientRect (). left-We (e, {marginLeft: 0}, function () {return e.getBoundingClientRect (). left})) + "px"}), S.each ({margin: "", padding: "", limite: "Width"}, função (i, o) {S.cssHooks [i + o] = {expand: function (e) {for (var t = 0, n = {} , r = "string" == tipo de e? e.split (""): [e]; t <4; t ++) n [i + ne [t] + o] = r [t] || r [t -2] || r [0]; retorno n}}, "margem"! == i && (S.cssHooks [i + o] .set = Je)}), S.fn.extend ({css: function ( e, t) {return $ (esta, função (e, t, n) {var r, i, o = {}, a = 0; if (Array.isArray (t)) {for (r = Ie (e), i = comprimento t; a <i; a ++) o [t [a]] = S.css (e, t [a] ,! 1, r ); return o} return void 0! == n? S.style (e, t, n): S.css (e, t)}, e, t, 1 <argument.length)}}), (( S.Tween = et) .prototype = {construtor: et, init: função (e, t, n, r, i, o) {this.elem = e, this.prop = n, this.easing = i || S.easing._default, this.options = t, this.start = this.now = this.cur (), this.end = r, this.unit = o || (S.cssNumber [n]? "": "px")}, cur: function () {var e = et.propHooks [this.prop]; retorne e && e.get? e.get (este): et.propHooks._default.get (this)}, execute: função (e) {var t, n = et.propHooks [this.prop]; retorna this.options.duration? this.pos = t = S.easing [this.easing] (e, this.options.duration * e , 0,1, this.options.duration): this.pos = t = e, this.now = (this.end-this.start) * t + this.start, this.options.step && this.options.step. chame (this.elem, this.now, this), n && n.set? n.set (this): et.propHooks._default.set (this), this}}). init.prototype = et.prototype, (et.propHooks = {_ padrão: {get: function (e) {var t; return 1! == e.elem.nodeType || null ! = e.elem [e.prop] && null == e.elem.style [e.prop]? e.elem [e.prop] :( t = S.css (e.elem, e.prop, "" )) && "auto"! == t? t: 0}, defina: function (e) {S.fx.step [e.prop]? S.fx.step [e.prop] (e): 1! == e.elem.nodeType ||! S.cssHooks [e.prop] && null == e.elem.style [Xe (e.prop)]? e.elem [e.prop] = e.now: S. style (e.elem, e.prop, e.now + e.unit)}}}). scrollTop = et.propHooks.scrollLeft = {set: function (e) {e.elem.nodeType && e.elem.parentNode && (e .elem [e.prop] = e.now)}}, S.easing = {linear: função (e) {retorno e}, balanço: função (e) {retorno.5-Math.cos (e * Math. PI) / 2}, _ padrão: "swing"}, S.fx = et.prototype.init, S.fx.step = {}; var tt, nt, rt, it, ot = / ^ (?: alternar | show | ocultar) $ /, em = / queueHooks $ /; função st () {nt && (! 1 === E.hidden && C.requestAnimationFrame? C.requestAnimationFrame (st): C.setTimeout (st, S.fx.interval), S.fx.tick ())} função ut () {retornar C.setTimeout (função () {tt = void 0} ), tt = Date.now ()} função lt (e, t) {var n, r = 0, i = {height: e}; para (t = t? 1: 0; r <4; r + = 2 -t) i ["margem" + (n = ne [r])] = i ["preenchimento" + n] = e; retorna t && (i.opacity = i.width = e), i} função ct (e , t, n) {for (var r, i = (ft.tweeners [t] || []). concat (ft.tweeners ["*"]), o = 0, a = i.length; o < a; o ++) if (r = i [o] .call (n, t, e)) retorna r} função ft (o, e, t) {var n, a, r = 0, i = ft.prefilters. length, s = S.Deferred (). always (function () {delete u.elem}), u = function () {if (a) return! 1; for (var e = tt || ut (), t = Math.max (0, l.startTime + l.duration-e), n = 1- (t / l.duration || 0), r = 0, i = l.tweens.length; r <i; r ++ ) l.tweens [r] .run (n); return s.notifyWith (o, [l, n, t]), n <1 && i? t: (i || s.notifyWith (o, [l, 1, 0]), s.resolveWith (o, [l]) ,! 1)}, l = s.promessa ({elem: o, props: S.extend ({}, e), opta: S.extend (! 0, {specialEasing: {}, easing: S.easing._default}, t), originalProperties: e, originalOptions: t, startTime: tt || ut (), duração: t.duration, tweens: [], createTween: function (e, t) {var n = S.Tween (o, l.opts, e, t, l.opts.specialEasing [e] || l.opts.easing); return l.tweens.push (n), n}, stop: function (e) {var t = 0, n = e? l.tweens. comprimento: 0; se (a) retornar isso; para (a =! 0; t <n; t ++) l.tweens [t] .run (1); return e? (s.notifyWith (o, [l, 1 , 0]), s.resolveWith (o, [l, e])): s.rejectWith (o, [l, e]), este}}), c = l.props; for (! Function (e, t) {var n, r, i, o, a; para (n em e) se (i = t [r = X (n)], o = e [n], Array.isArray (o) && (i = o [1], o = e [n] = o [0]), n! == r && (e [r] = o, exclua e [n]), (a = S.cssHooks [r]) && "expandir" em a) para (n em o = a.expandir (o), exclua e [r], o) n em e || (e [n] = o [n], t [n] = i) ; else t [r] = i} (c, l.opts.specialEasing); r <i; r ++) if (n = ft.prefilters [r] .call (l, o, c, l.opts)) return m (n.stop) && (S._queueHooks (l.elem, l.opts.queue) .stop = n.stop.bind (n)), n; retorna S.map (c, ct, l), m (l.opts.start) && l.opts.start.call (o, l), l.progress (l.opts.progress) .done (l.opts.done, l.opts.complete). fail (l.opts.fail) .sempre (l.opts.always), S.fx.timer (S.extend (u, {elem: o, anim: l, fila: l.opts.queue})), l} S.Animation = S.extend (ft, {tweeners: {"*": [function (e, t) {var n = this.createTween (e, t); return se (n.elem, e, te .exec (t), n), n}]}, interpolador: function (e, t) {m (e)? (t = e, e = ["*"]): e = e.match (P) ; para (var n, r = 0, i = e.length; r <i; r ++) n = e [r], ft.tweeners [n] = ft.tweeners [n] || [], ft.tweeners [n] .unshift (t)}, pré-filtros: [function (e, t, n) {var r, i, o, a, s, u, l, c, f = "width" em t || "height "em t, p = isto, d = {}, h = e.style, g = e.nodeType && ae (e), v = Y.get (e," fxshow "); para (r na fila.n || (nulo == (a = S._queueHooks (e, "fx"))).sem fila && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function () {a.unqueued || s ()}), a.unqueued ++, p.always (function () {p .always (function () {a.unqueued -, S.queue (e, "fx"). length || a.empty.fire ()})})), t) if (i = t [r] , ot.test (i)) {if (excluir t [r], o = o || "alternar" === i, i === (g? "ocultar": "mostrar")) {if (" mostre "! == i ||! v || void 0 === v [r]) continue; g =! 0} d [r] = v && v [r] || S.style (e, r)} se ((u =! S.isEmptyObject (t)) ||! S.isEmptyObject (d)) para (r em f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY ], null == (l = v && v.display) && (l = Y.get (e, "exibição")), "nenhum" === (c = S.css (e, "exibição")) && ( l? c = l: (le ([e] ,! 0), l = e.style.display || l, c = S.css (e, "exibição"), le ([e]))), ("inline" === c || "bloco inline" === c && null! = l) && "none "= S.css (e," float ") && (u || (p.done (function () {h.display = l})), null == l&& (c = h.display, l = "none" === c? "": c)), h.display = "bloco em linha")), n.overflow && (h.overflow = "oculto", p.always (function () {h.overflow = n.fluxo de fluxo [0], h.fluxo de fluxoX = n.fluxo de fluxo [1], h.fluxo de fluxoY = n.fluxo de fluxo [2]})), u =! 1, d) u || (v? v && (g = v.hidden): v = Y.access (e, "fxshow", {display: l}), o && (v.hidden =! g), g && le ([e] ,! 0), p. feito (função () {para (r em g || le ([e]), Y.remove (e, "fxshow"), d) S.style (e, r, d [r])})), u = ct (g? v [r]: 0, r, p), r em v || (v [r] = u.start, g && (u.end = u.start, u.start = 0)) }], prefilter: function (e, t) {t? ft.prefilters.unshift (e): ft.prefilters.push (e)}}), S.speed = function (e, t, n) {var r = e && "objeto" == tipo de e? S.extend ({}, e): {complete: n ||! n &&t || m (e) && e, duration: e, flexibilização: n && t || t &&! m (t) && t}; return S.fx.off?r.duration=0:"number"!=typeof r.duration && ( r.duração em S.fx.speeds? r.duration = S.fx.speeds [r.duration]: r.duration = S.fx.speeds._default), null! = r.queue &&! 0! == r .queue || (r.queue = "fx"), r.old = r.complete, r.complete = function () {m (r.old) && r.old.call (this), r.queue && S.dequeue (this, r.queue)}, r}, S.fn.extend ({fadeTo: function (e, t, n, r) {retorna this.filter (ae) .css ("opacidade", 0) .show () .end (). animar ({opacidade: t}, e, n, r)}, animar: função (t, e, n, r) {var i = S. isEmptyObject (t), o = S. velocidade (e, n, r), a = função () {var e = ft (isto, S. extensão ({}, t), o); (i || Y.get (isto, "acabamento")) && e.stop (! 0)}; retornar a.finish = a, i ||! 1 === o.queue? this.each (a): this.queue (o.queue, a)}, stop: function (i, e, o) {var a = função (e) {var t = e.para;delete e.stop, t (o)}; retorne "string"! = tipo de i && (o = e, e = i, i = nulo 0), e && this.queue (i || "fx", []), este .each (function () {var e =! 0, t = null! = i && i + "queueHooks", n = S.timers, r = Y.get (this); if (t) r [t] && r [t] .stop && a (r [t]); caso contrário, para (t em r) r [t] && r [t] .stop && at.test (t) && a (r [t]); for (t = n.length; t-- ;) n [t] .elem! == isto || nulo! = i && n [t] .queue! == i || (n [t] .anim.stop (o), e =! 1, n.splice (t, 1)) ;! e && | | S. fila de espera (this, i)})}, finish: function (a) {return! 1! == a && (a = a || "fx"), this. cada (função () {var e, t = Y.get (este), n = t [a + "fila"], r = t [a + "filaHooks"], i = S.timers, o = n? n. comprimento: 0; para (t.finish =! 0, S.queue (this, a, []), r && r.stop && r.stop.call (this,! 0), e = i.length; e--;) i [e] .elem === isso && i [e] .queue === a && (i [e] .anim.stop (! 0), i.splice (e,1)); para (e = 0; e <o; e ++) n [e] && n [e] .finish && n [e] .finish.call (this); delete t.finish})}}), S.each (["alternar", "mostrar", "ocultar"], função (e, r) {vari = S.fn [r]; S.fn [r] = função (e, t, n) {return null == e || "booleano" == tipo de e? i.apply (this, argumentos): this.animate (lt (r,! 0), e, t, n)}}), S.each ({slideDown : lt ("show"), slideUp: lt ("hide"), slideToggle: lt ("toggle"), fadeIn: {opacidade: "show"}, fadeOut: {opacidade: "hide"}, fadeToggle: {opacidade : "alternar"}}, função (e, r) {S.fn [e] = função (e, t, n) {retorna this.animate (r, e, t, n)}}), S.timers = [], S.fx.tick = function () {var e, t = 0, n = temporizadores S. para for (tt = Date.now (); t <comprimento n; t ++) (e = n [ t]) () || n [t]! == e || n.splice (t -, 1); n.length || S.fx.stop (), tt = vazio 0}, S.fx .timer = função (e) {S.timers.push (e), S.fx.start ()}, S.fx.interval = 13, S.fx.start = function () {nt || (nt =! 0, st ())}, S.fx.stop = função () {nt = null}, S.fx.speeds = {lento: 600, rápido: 200 , _default: 400}, S.fn.delay = function (r, e) {return r = S.fx && S.fx.speeds [r] || r, e = e || "fx", this.queue (e , function (e, t) {var n = C.setTimeout (e, r); t.stop = function () {C.clearTimeout (n)}})}, rt = E.createElement ("input"), it = E.createElement ("selecione"). appendChild (E.createElement ("opção")), rt.type = "caixa de seleção", y.checkOn = ""! == rt.value, y.optSelected = it. selecionado, (rt = E.createElement ("input")). value = "t", rt.type = "radio", y.radioValue = "t" === rt.value; var pt, dt = S. expr.attrHandle; S.fn.extend ({attr: function (e, t) {return $ (this, S.attr, e, t, 1 <argument.length)}, removeAttr: function (e) {retorna este .each (function () {S.removeAttr (this, e)})}}), S.extend ({attr: function (e, t, n) {var r, i, o = e.nodeType; if (3! == o && 8! == o && 2! == o) retornará "indefinido" == tipo de e.getAttribute? S.prop (e, t, n) :( 1 === o && S.isXMLDoc (e ) || (i = S.attrHooks [t.toLowerCase ()] || (S.expr.match.bool.test (t)? pt: void 0)), void 0! == n? null === n? void S.removeAttr (e, t): i && "define" em i && void 0! == (r = i.set (e, n, t))? r: (e.setAttribute (t, n + "") , n): i && "obtém" em i && null! == (r = i.get (e, t))? r: null == (r = S.find.attr (e, t))? void 0: r )}, attrHooks: {type: {set: function (e, t) {if (! y.radioValue && "radio" === t && A (e, "input")) {var n = e.value; return e. setAttribute ("tipo", t), n && (e.value = n), t}}}}, removeAttr: função (e, t) {var n, r = 0, i = t && t.match (P); se (i && 1 === e.nodeType) enquanto (n = i [r ++]) e.removeAttribute (n)}}), pt = {set: function (e, t, n) {return! 1 === t? S.removeAttr (e, n): e.setAttribute (n, n), n}}, S.each (S.expr.match.bool.source.match (/ \ w + / g), função (e, t) {var a = dt [t] || S.find.attr; dt [t] = função (e, t, n) {var r, i, o = t.toLowerCase (); return n || (i = dt [o], dt [o] = r, r = null! = a (e, t, n)? o: null, dt [o] = i), r}}); var ht = / ^ (?: input | select | textarea | button) $ / i, gt = / ^ (?: a | area) $ / i; função vt (e) {return (e.match (P) || []). join ("")} função yt (e) { return e.getAttribute && e.getAttribute ("class") || ""} função mt (e) {return Array.isArray (e)? e: "string" == tipo de e&& e.match (P) || []} S .fn.extend ({prop: function (e, t) {return $ (this, S.prop, e, t, 1 <argument.length)}, removeProp: function (e) {return this.each (function ( ) {delete this [S.propFix [e] || e]})}}), S.extend ({prop: function (e, t, n) {var r, i, o = e.nodeType; if ( 3! == o && 8! == o && 2! == o) return 1 === o && S.isXMLDoc (e) || (t = S.propFix [t] || t, i = S.propHooks [t]), void 0! == n? i && "set" em i && void 0! == (r = i.set (e, n, t))? r: e [t] = n: i && "get "em i && null! == (r = i.get (e, t))? r: e [t]}, propHooks: {tabIndex: {get: function (e) {var t = S.find.attr (e , "tabindex"); return t? parseInt (t, 10): ht.test (e.nodeName) || gt.test (e.nodeName) && e.href? 0: -1}}}, propFix: {" para ":" htmlFor "," class ":" className "}}), y.optSelected || (S.propHooks.selected = {get: function (e) {var t = e.parentNode; return t && t.parentNode && t. parentNode.selectedIndex, null}, set: function (e) {var t = e.parentNode; t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)}}), S.each (["tabIndex", "readOnly "," maxLength "," cellSpacing "," cellPadding "," rowSpan "," colSpan ","useMap "," frameBorder "," contentEditable "], function () {S.propFix [this.toLowerCase ()] = this}), S.fn.extend ({addClass: function (t) {var e, n, r, i, o, a, s, u = 0; if (m (t)) retorna this.each (function (e) {S (this) .addClass (t.call (this, e, yt (this)) ))}); if ((e = mt (t)). length) while (n = this [u ++]) if (i = yt (n), r = 1 === n.nodeType && "" + vt ( i) + "") {a = 0; while (o = e [a ++]) r.indexOf ("" + o + "") <0 && (r + = o + ""); i! == (s = vt ( r)) && n.setAttribute ("classe", s)} retorne isso}, removeClass: function (t) {var e, n, r, i, o, a, s, u = 0; if (m (t) ) retorna this.each (function (e) {S (this) .removeClass (t.call (this, e, yt (this)))}); if (! argument.length) retorna this.attr ("class" , ""); if ((e = mt (t)). length) while (n = this [u ++]) if (i = yt (n), r = 1 === n.nodeType && "" + vt ( i) + "") {a = 0;while (o = e [a ++]) while (-1 <r.indexOf ("" + o + "")) r = r.replace ("" + o + "", ""); i! == (s = vt (r)) && n.setAttribute ("classe", s)} retorna isso}, toggleClass: function (i, t) {var o = tipo de i, a = "string" === o || Array.isArray ( i); return "boolean" == tipo de && a? t? this.addClass (i): this.removeClass (i): m (i)? this.each (function (e) {S (this) .toggleClass (i .call (this, e, yt (this), t), t)}): this.each (function () {var e, t, n, r; if (a) {t = 0, n = S ( this), r = mt (i); while (e = r [t ++]) n.hasClass (e)? n.removeClass (e): n.addClass (e)} else void 0! == i && "boolean" ! == o || ((e = yt (this)) && Y.set (this, "__ className __", e), this.setAttribute && this.setAttribute ("class", e ||! 1 === i? "" : Y.get (este, "__ className __") || ""))})}, hasClass: function (e) {var t, n, r = 0;t = "" + e + ""; while (n = this [r ++]) if (1 === n.nodeType && - 1 <("" + vt (yt (n)) + "") .indexOf (t) ); return! 0; return! 1}}); var xt = / \ r / g; S.fn.extend ({val: function (n) {var r, e, i, t = this [0]; return argumentos.length? (i = m (n), this.each (function (e) {var t; 1 === this.nodeType && (null == (t = i? n.call (this, e, S ( this) .val ()): n)? t = "": "number" == typeof t? t + = "": Array.isArray (t) && (t = S.map (t, função (e) { return null == e? "": e + ""})), (r = S.valHooks [this.type] || S.valHooks [this.nodeName.toLowerCase ()]) && "set" em r && void 0! == r.set (this, t, "value") || (this.value = t))})): t? (r = S.valHooks [t.type] || S.valHooks [t.nodeName .toLowerCase ()]) && "get" em r && void 0! == (e = r.get (t, "valor"))? e: "string" == typeof (e = t.value)? e.substitua (xt, ""): null == e? "": e: void 0}}), S.extend ({valHooks: {option: {get: function (e) {var t = S.find.attr (e, "valor"); retornar nulo! = t? t: vt (S.text (e))}}, selecione: {get: function (e) {var t, n, r, i = e.options , o = e.selectedIndex, a = "selecionar um" === e.type, s = a? null: [], u = a? o + 1: i.length; for (r = o <0? u: a? o: 0; r <u; r ++) if (((n = i [r]). selected || r === o) &&! n.disabled && (! n.parentNode.disabled ||! A (n.parentNode, "optgroup"))) {if (t = S (n) .val (), a) return t; s.push (t)} return s}, defina: function (e, t) {var n, r, i = e.opções, o = S.makeArray (t), a = i.length; while (a -) ((r = i [a]). selected = -1 <S. inArray (S.valHooks.option.get (r), o)) && (n =! 0); return n || (e.selectedIndex = -1), o}}}}), S.each ([" radio "," checkbox "], function () {S.valHooks [this] = {set: function (e, t) {if (Array.isArray (t)) retorna e.checked = -1 <S.inArray ( S (e) .val ()t)}}, y.checkOn || (S.valHooks [this] .get = function (e) {return null === e.getAttribute ("value")? "on": e.value})}) , y.focusin = "onfocusin" em C; var bt = / ^ (?: focusinfocus | focusoutblur) $ /, wt = function (e) {e.stopPropagation ()}; S.extend (S.event, {trigger : function (e, t, n, r) {var i, o, a, s, u, l, c, f, p = [n || E], d = v.call (e, "tipo") ? e.type: e, h = v.call (e, "namespace")? e.namespace.split ("."): []; if (o = f = a = n = n || E, 3 ! == n.nodeType && 8! == n.nodeType &&! bt.test (d + S.event.triggered) && (- 1 <d.indexOf (".") && (d = (h = d.split (" . ")). shift (), h.sort ()), u = d.índice (de:") <0 && "em" + d, (e = e [S.expando]? e: novo S.Event (d, "objeto" == tipo de e && e)). isTrigger = r? 2: 3, e.namespace = h.join ("."), e.rnamespace = e.namespace? new RegExp ("(^ | \ \.) "+ h.junção ("\\. (?:. * \\. |)") + "(\\. | $)"): null, e.result = void 0, e.target || (e.target = n ), t = null == t? [e]: S.makeArray (t, [e]), c = S.event.special [d] || {}, r ||! c.trigger ||! 1 ! == c.trigger.apply (n, t))) {if (! r &&! c.noBubble &&! x (n)) {for (s = c.delegateType || d, bt.test (s + d) || (o = o.parentNode); o; o = o.parentNode) p.push (o), a = o; a === (n.ownerDocument || E) && p.push (a.defaultView || a.parentWindow || C)} i = 0; while ((o = p [i ++]) &&! e.isPropagationStopped ()) f = o, e.type = 1 <i? s: c.bindType || d , (l = (Y.get (o, "eventos") || Object.create (null)) [e.type] && Y.get (o, "manipulador")) && l.apply (o, t), ( l = u && o [u]) && l.apply && V (o) && (e.result = l.apply (o, t) ,! 1 === resultado e. && e.preventDefault ()); return e.type = d, r || e.isDefaultPrevented () || c._default &&! 1! == c._default.apply (p.pop (), t) ||! V (n) || u &&m (n [d]) &&! x (n) && ((a = n [u]) && (n [u] = null), S.event.triggered = d, e.isPropagationStopped () && f.addEventListener ( d, wt), n [d] (), e.isPropagationStopped () && f.removeEventListener (d, wt), S.event.triggered = vazio 0, a && (n [u] = a)), e.result} }, simule: function (e, t, n) {var r = S.extend (novo S.Event, n, {tipo: e, isSimulated:! 0}); S.event.trigger (r, null, t )}}), S.fn.extend ({trigger: function (e, t) {retorna this.each (function () {S.event.trigger (e, t, this)})}, triggerHandler: function ( e, t) {var n = this [0]; se (n) retornar S.event.trigger (e, t, n,! 0)}}), y.focusin || S.each ({focus: " focusin ", blur:" focusout "}, função (n, r) {vari = função (e) {S.event.simulate (r, e.target, S.event.fix (e))}; S. event.special [r] = {setup: function () {var e = this.ownerDocument || this.document || isto, t = Y.access (e, r); t || e.addEventListener (n, i ,! 0), acesso Y (e, r, (t || 0) +1)},teardown: function () {var e = this.ownerDocument || this.document || this, t = Y.access (e, r) -1; t? Y.access (e, r, t) :( e. removeEventListener (n, i,! 0), Y.remove (e, r))}}}); var Tt = local C., Ct = {guid: Date.now ()}, Et = / \? /; S.parseXML = função (e) {var t; if (! E || "string"! = Typeof e) return null; try {t = (new C.DOMParser) .parseFromString (e, "text / xml") } catch (e) {t = void 0} retorna t &&! t.getElementsByTagName ("parsererror"). length || S.error ("XML inválido:" + e), t}; var St = / \ [\] $ /, kt = / \ r? \ n / g, At = / ^ (?: enviar | botão | imagem | redefinir | arquivo) $ / i, Nt = / ^ (?: entrada | selecionar | textarea | keygen) / i; função Dt (n, e, r, i) {var t; if (Array.isArray (e)) S.each (e, função (e, t) {r || St.test (n)? i (n, t): Dt (n + "[" + ("objeto" == tipo de t && null! = t? e: "") + "]", t, r, i)}); caso contrário, se (r | | "objeto"! == w (e)) i (n, e); mais para (t em e) Dt (n + "["+ t + "]", e [t], r, i)} S.param = função (e, t) {var n, r = [], i = função (e, t) {var n = m (t )? t (): t; r [r.length] = encodeURIComponent (e) + "=" + encodeURIComponent (null == n? "": n)}; if (null == e) retorna ""; se (Array.isArray (e) || e.jquery &&! S.isPlainObject (e)) S.each (e, function () {i (this.name, this.value)}); mais para (n em e) Dt (n, e [n], t, i); return r.join ("&")}, S.fn.extend ({serialize: function () {return S.param (this.serializeArray ())} , serializeArray: function () {retorna this.map (function () {var e = S.prop (this, "elements"); retorna e? S.makeArray (e): this}). filter (function () { var e = this.type; retorna this.name &&! S (this) .is (": disabled") && Nt.test (this.nodeName) &&! At.test (e) && (this.checked ||! pe. teste (e))}). map (function (e, t) {var n = S (this) .val (); return null == n? null: Array.isArray (n)? S.map (n,função (e) {retornar {nome: t.name, valor: e.replace (kt, "\ r \ n")}}): {nome: t.name, valor: n.replace (kt, "\ r \ n ")}}). get ()}}); var jt = /% 20 / g, qt = / #. * $ /, Lt = / ([? &]) _ = [^ &] * / , Ht = / ^ (. *?): [\ T] * ([^ \ r \ n] *) $ / gm, Ot = / ^ (?: GET | HEAD) $ /, Pt = / ^ \ / \ //, Rt = {}, Mt = {}, It = "* /". Concat ("*"), Wt = E.createElement ("a"); função Ft (o) {função de retorno (e, t) {"string"! = tipo de e && (t = e, e = "*"); var n, r = 0, i = e.toLowerCase (). match (P) || []; if (m ( t)) while (n = i [r ++]) "+" === n [0]? (n = n.slice (1) || "*", (o [n] = o [n] || []). unshift (t)) :( o [n] = o [n] || []). push (t)}} função Bt (t, i, o, a) {var s = {}, u = t === Mt; função l (e) {var r; retorno s [e] =! 0, S.each (t [e] || [], função (e, t) {var n = t (i, o, a); return "string"! = typeof n || u || s [n]? u?! (r = n): void 0: (i.dataTypes.unshift (n), l ( n) ,! 1)}), r} retorna l (i.dataTypes [0]) ||! s ["*"] && l ("*")} função $ t (e, t) {var n, r, i = S.ajaxSettings.flatOptions || {}; para (n em t) vazio 0! == t [n] && ( (i [n]? e: r || (r = {})) [n] = t [n]); retorna r && S.extend (! 0, e, r), e} Wt.href = Tt.href , S.extend ({active: 0, lastModified: {}, etag: {}, ajaxSettings: {url: Tt.href, digite: "GET", isLocal: / ^ (?: about | app | app-storage | . + - extensão | arquivo | res | widget): $ /. test (protocolo.tt), global:! 0, processData:! 0, assíncrono:! 0, contentType: "application / x-www-form-urlencoded; charset = UTF-8 ", aceita: {" * ": It, texto:" text / plain ", html:" text / html ", xml:" application / xml, text / xml ", json:" application / json , texto / javascript "}, conteúdo: {xml: / \ bxml \ b /, html: / \ bhtml /, json: / \ bjson \ b /}, responseFields: {xml:" responseXML ", texto:" responseText " , json: "responseJSON"}, conversores: {"* text": String "text html ":! 0," text json ": JSON.parse," text xml ": S.parseXML}, flatOptions: {url:! 0, context:! 0}}, ajaxSetup: function (e, t) { Retorna t? t) {"objeto" == tipo de e && (t = e, e = nulo 0), t = t || {}; var c, f, p, n, d, r, h, g, i, o, v = S.ajaxSetup ({}, t), y = v.context || v, m = v.context && (y.nodeType || y.jquery)? S (y): S.event, x = S. Adiado (), b = S.Callbacks ("uma vez memória"), w = v.statusCode || {}, a = {}, s = {}, u = "cancelado", T = {readyState: 0, getResponseHeader : function (e) {var t; if (h) {if (! n) {n = {}; while (t = Ht.exec (p)) n [t [1] .toLowerCase () + ""] = (n [t [1] .toLowerCase () + ""] || []). concat (t [2])} t = n [e.toLowerCase () + ""]} retorna nulo == t? null: t.join (",")}, getAllResponseHeaders: function () {return h? p: null},setRequestHeader: function (e, t) {return null == h && (e = s [e.toLowerCase ()] = s [e.toLowerCase ()] || e, a [e] = t), this}, overrideMimeType : function (e) {return null == h && (v.mimeType = e), this}, statusCode: function (e) {var t; if (e) if (h) T. sempre (e [T.status] ); else for (t in e) w [t] = [w [t], e [t]]; retorne isso}, abort: function (e) {var t = e || u; return c && c.abort ( t), l (0, t), isso}}; if (x.promise (T), v.url = ((e || v.url || Tt.href) + ""). replace (Pt, Tt.protocol + "//"), v.type = t.method || t.type || v.method || v.type, v.dataTypes = (v.dataType || "*"). ToLowerCase () .match (P) || [""], null == v.crossDomain) {r = E.createElement ("a"); tente {r.href = v.url, r.href = r.href, v .crossDomain = Wt.protocol + "//" + Wt.host! = r.protocol + "//" + r.host} catch (e) {v.crossDomain =! 0}} if (v.data && v.processData && "string "! = tipo de v.data && (v.data = S.param (v.data, v.tradicional)), Bt (Rt, v, t, T), h) retorna T; for (i in (g = S.event && v.global) && 0 == S.active ++ && S.event.trigger ("ajaxStart"), v.type = v.type.toUpperCase (), v.hasContent =! Ot.test (v.type), f = v.url. substituir (qt, ""), v.hasContent? v.data && v.processData && 0 === (v.contentType || ""). indexOf ("application / x-www-form-urlencoded") && (v.data = v.data.replace (jt, "+")) :( o = v.url.slice (f.length), v.data && (v.processData || "string" == tipo de v.data) && (f + = (Et.test (f)? "&": "?") + V.data, exclua v.data) ,! 1 === v.cache && (f = f.replace (Lt, "$ 1"), o = (Et.test (f)? "&": "?") + "_ =" + Ct.guid +++ o), v.url = f + o), v.ifModified && (S.lastModified [ f] && T.setRequestHeader ("If-Modified-Since ", S.lastModified [f]), S.etag [f] && T.setRequestHeader (" If-None-Match ", S.etag [f])), (v.data && v.hasContent && 1 ! == v.contentType || t.contentType) && T.setRequestHeader ("Tipo de conteúdo", v.contentType), T.setRequestHeader ("Aceitar", v.dataTypes [0] && v.accepts [v.dataTypes [0 ]]? v.accepts [v.dataTypes [0]] + ("*"! == v.dataTypes [0]? "," + It + "; q = 0,01": ""): v.accepts [" * "]), v.headers) T.setRequestHeader (i, v.headers [i]); if (v.beforeSend && (! 1 === v.beforeSend.call (y, T, v) || h)) ) retorna T.abort (); if (u = "abort", b.add (v.complete), T.done (v.success), T.fail (v.error), c = Bt (Mt, v , t, T)) {if (T.readyState = 1, g &&m.trigger ("ajaxSend", [T, v]), h) retorna T; v.async && 0 <v.timeout && (d = C.setTimeout (function () {T.abort ("timeout ")}, v.timeout)); tente {h =! 1, c.send (a, l)} catch (e) {se (h) jogar e; l (-1, e)}} else l (-1, "No Transport"); função l (e, t, n, r) {var i, o, a, s, u, l = t; h || (h =! 0, d && C.clearTimeout ( d), c = nulo 0, p = r || "", T.readyState = 0 <e? 4: 0, i = 200 <= e && e <300 || 304 === e, n && (s = função ( e, t, n) {var r, i, o, a, s = e.contents, u = e.dataTypes; while ("*" === u [0]) u.shift (), void 0 = == r && (r = e.mimeType || t.getResponseHeader ("Tipo de conteúdo")); if (r) for (i in s) if (s [i] && s [i] .test (r)) { u.unshift (i); break} if (u [0] em n) o = u [0]; caso contrário {para (i em n) {if (! u [0] || e.conversores [i + "" + u [0]]) {o = i; quebrar} a || (a = i)} o = o || a} se (o) retornar o! == u [0] && u.shift (o), n [o]} (v, T, n)) ,! i && - 1 <S.inArray ("script", v.dataTypes) && (v.converters ["text script"] = function () {}), s = função (e, t, n, r) {var i, o, a, s, u,l = {}, c = e.dataTypes.slice (); if (c [1]) para (a em conversores eletrônicos) l [a.toLowerCase ()] = conversores eletrônicos [a]; o = c. shift (); while (o) if (e.responseFields [o] && (n [e.responseFields [o]] = t) ,! u && r && e.dataFilter && (t = e.dataFilter (t, e.dataType)), u = o, o = c.shift ()) if ("*" === o) o = u; caso contrário, se ("*"! == u && u! == o) {if (! (a = l [ u + "" + o] || l ["*" + o])) para (i em l) se ((s = divisão i (""))) [1] === o && (a = l [u + "" + s [0]] || l ["*" + s [0]])) {! 0 === a? a = l [i] :! 0! == l [i] && (o = s [0], c.shift (s [1])); break} if (! 0! == a) if (a && e ["lança"]) t = a (t); caso contrário, tente {t = a (t)} catch (e) {return {state: "parsererror", erro: a? e: "Nenhuma conversão de" + u + "para" + o}}} return {state: "success", data: t} } (v, s, T, i), i? (v.ifModified && ((u = T.getResponseHeader ("Última modificação"))) && (S.lastModified [f] = u), (u = T.getResponseHeader ("etag")) && (S.etag [f] = u)), 204 === e || "HEAD" = == v.type? l = "nocontent": 304 === e? l = "não modificado" :( l = s.state, o = s.data, i =! (a = s.error))): (a = l,! e && l || (l = "erro", e <0 && (e = 0))), T.status = e, T.statusText = (t || l) + "", i? x .resolveWith (y, [o, l, T]): x.rejectWith (y, [T, l, a]), T.statusCode (w), w = nulo 0, g && m.trigger (i? "ajaxSuccess" : "ajaxError", [T, v, i? o: a]), b.fireWith (y, [T, l]), g&& (m.trigger ("ajaxComplete", [T, v]), - S.active || S.event.trigger ("ajaxStop")))} retornar T}, getJSON: function (e, t, n) {retornar S.get (e, t, n, "json")}, getScript: function (e, t) {retorna S.get (e, void 0, t, "script")}}), S.each (["get", "post"], função (e, i) { S [i] = função (e, t, n,r) {retornar m (t) && (r = r || n, n = t, t = nulo 0), S.ajax (S.extend ({url: e, tipo: i, dataType: r, data: t, sucesso: n}, S.isPlainObject (e) && e))}}), S.ajaxPrefilter (função (e) {var t; para (t em e.headers) "tipo de conteúdo" === t. toLowerCase () && (e.contentType = e.headers [t] || "")}), S._evalUrl = function (e, t, n) {retorne S.ajax ({url: e, digite: "GET ", dataType:" script ", cache:! 0, assíncrono:! 1, global:! 1, conversores: {" script de texto ": function () {}}, dataFilter: function (e) {S.globalEval (e , t, n)}})}, S.fn.extend ({wrapAll: function (e) {var t; retorna isso [0] && (m (e) && (e = e.call (this [0] )), t = S (e, este [0] .Documento proprietário) .eq (0) .clone (! 0), este [0] .parentNode && t.insertBefore (this [0]), t.map (function () () {var e = this; while (e.firstElementChild) e = e.firstElementChild; return e}). append (this)), this}, wrapInner: function (n) {return m (n)? this.each (function (e) {S (this) .wrapInner (n.call (this, e))}): this.each (function () {var e = S (this), t = e.contents (); t.length? t.wrapAll (n): e.append (n)})}, wrap: function (t) {var n = m (t); retorna this.each (function (e) {S (this) .wrapAll (n? t.call (this, e): t)})}, desembrulhe: function (e) {retorna this.parent (e) .not ("body"). each (function () {S ( this) .replaceWith (this.childNodes)}), this}}), S.expr.pseudos.hidden = function (e) {return! S.expr.pseudos.visible (e)}, S.expr.pseudos. visible = function (e) {return !! (e.offsetWidth || e.offsetHeight || e.getClientRects (). length)}, S.ajaxSettings.xhr = function () {try {return new C.XMLHttpRequest} catch (e) {}}; var _t = {0: 200,1223: 204}, zt = S.ajaxSettings.xhr (); y.cors = !! zt && "withCredentials" em zt, y.ajax = zt =! ! zt, S.ajaxTransport (função (i) {var o, a; if (y.cors || zt &&! i.crossDomain) return {send: function (e, t) {var n, r = i.xhr ( ); if (r.open (i.type, i.url, i.async, i.username, i.password), i.xhrFields) para (n em i.xhrFields) r [n] = i.xhrFields [n]; para (n em i.mimeType && r.overrideMimeType && r.overrideMimeType (i.mimeType), i.crossDomain || e ["X-Requested-With"] || (e ["X-Requested-With"] = "XMLHttpRequest"), e) r.setRequestHeader (n, e [ n]); o = function (e) {return function () {o && (o = a = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, "abort" === e? r.abort (): "erro" === e? "número"! = tipo de status.t (0, "erro"): t (status.r, texto.status): t (_t [ r.status] || r.status, r.statusText, "text"! == (r.responseType || "text") || "string"! = tipo de r.responseText? {binário: r.response}: {text: r.responseText}, r.getAllResponseHeaders ())}}, r.onload = o (), a = r.onerror = r.ontimeout = o ("erro"), nulo 0! == r. onabort? r.onabort = a: r.onreadystatechange = function () {4 === r.readyState && C.setTimeout (function () {o && a ()})}, o = o ("abortar"); tente {r.send (i. hasContent && i.data || null)} catch (e) {if (o) throw e}}, abort: function () {o && o ()}}}), S.ajaxPrefilter (function (e) {e.crossDomain && (e .contents.script =! 1)}), S.ajaxSetup ({aceita: {script: "texto / javascript, aplicativo / javascript, aplicativo / ecmascript, aplicativo / x-ecmascript"}, conteúdo: {script: / \ b script (?: java | ecma) \ b /}, conversores: {"script de texto": function (e) {return S.globalEval (e), e}}}), S.ajaxPrefilter ("script", function ( e) {void 0 === e.cache && (e.cache =! 1), e.crossDomain && (e.type = "GET")}), S.ajaxTransport ("script", função (n) {var r , i; if (n.crossDomain || n.scriptAttrs) retorna {send: function (e, t) {r = S ("<script>") .attr (n.scriptAttrs || {}). prop ({charset: n.scriptCharset, src: n.url}). on ("erro de carregamento", i = função (e) {r.remove (), i = null, e &&t ( "error" === e.type? 404: 200, e.type)}), E.head.appendChild (r [0])}, anula: function () {i && i ()}}}); var Ut , Xt = [], Vt = / (=) \? (? = & | $) | \? \? /; S.ajaxSetup ({jsonp: "retorno de chamada", jsonpCallback: function () {var e = Xt. pop () || S.expando + "_" + Ct.guid ++; retorne este [e] =! 0, e}}), S.ajaxPrefilter ("json jsonp", função (e, t, n) {var r , i, o, a =! 1! == e.jsonp && (Vt.test (e.url)? "url": "string" == tipo de e.data && 0 === (e.contentType || "") .indexOf ("application / x-www-form-urlencoded") && Vt.test (e.data) && "data"); if (a || "jsonp" === e.dataTypes [0]) return r = e.jsonpCallback = m (e.jsonpCallback)? e.jsonpCallback (): e.jsonpCallback, a? e [a] = e [a].substituir (Vt, "$ 1" + r) :! 1! == e.jsonp && (e.url + = (Et.test (e.url)? "&": "?") + e.jsonp + "=" + r), e.converters ["script json"] = function () {return o || S.error (r + "não foi chamado"), o [0]}, e.dataTypes [0] = "json", i = C [r], C [r] = função () {o = argumentos}, n. sempre (função () {void 0 === i? S (C) .removeProp (r): C [r] = i, e [r] && (e.jsonpCallback = t.jsonpCallback, Xt.push (r)), o &&m (i) &&i (o [0]), o = i = void 0}), "script"} ), y.createHTMLDocument = ((Ut = E.implementation.createHTMLDocument (""). body) .infoHTML = "<form> </form> <form> </form>", 2 === Ut.childNodes. length), S.parseHTML = function (e, t, n) {return "string"! = typeof e? [] :( "boolean" == typeof t && (n = t, t =! 1), t || (y.createHTMLDocument? ((r = (t = E.implementation.createHTMLDocument ("")). createElement (" base ")). href = E.location.href, t.head.appendChild (r)): t = E), o =! n && [], (i = N.exec (e ))? [t.createElement (i [1])] :( i = xe ([e], t, o), o && o.length && S (o) .remove (), S.merge ([], i.childNodes ));; var r, i, o}, S.fn.load = function (e, t, n) {var r, i, o, a = this, s = e.indexOf (""); return- 1 <s && (r = vt (e.slice (s)), e = e.slice (0, s)), m (t)? (N = t, t = vazio 0): t && "objeto" == typeof t && (i = "POST"), 0 <a.length && S.ajax ({url: e, tipo: i || "GET", dataType: "html", dados: t}). concluído (função (e) {o = argumentos, a.html (r? S ("<div>") .append (S.parseHTML (e)). find (r): e)}). always (n && function (e, t) {a .each (function () {n.apply (this, o || [e.responseText, t, e])})}), this}, S.expr.pseudos.animated = function (t) {return S. grep (S.timers, função (e) {return t === e.elem}). length}, S.offset = {setOffset: function (e, t, n) {var r, i, o, a, s, u, l = S.css (e, "posição"), c = S (e), f = { }; "estático" === l && (e.style.posição = "relativa"), s = c.offset (), o = S.css (e, "top"), u = S.css (e, "esquerda"), ("absoluto" === l || "fixo" === l) && - 1 <(o + u) .indexOf ("auto")? (a = (r = c.position ( )). top, i = r.left) :( a = parseFloat (o) || 0, i = parseFloat (u) || 0), m (t) && (t = t.call (e, n, S.extend ({}, s))), null! = T.top && (f.top = t.top-s.top + a), null! = T.left && (f.left = t.left-s .left + i), "using" em t? t.using.call (e, f) :( "número" == tipo de f.top && (f.top + = "px"), "número" == tipo de f .left && (f.left + = "px"), c.css (f))}}, S.fn.extend ({offset: function (t) {if (argument.length) retorna nulo 0 === t? this: this.each (function (e) {S.offset.setOffset (this, t, e)});var e, n, r = este [0]; retorna r? r.getClientRects (). length? (e = r.getBoundingClientRect (), n = r.ownerDocument.defaultView, {top: e.top + n.pageYOffset , esquerda: e.left + n.pageXOffset}): {top: 0, esquerda: 0}: void 0}, posição: function () {if (this [0]) {var e, t, n, r = this [0], i = {top: 0, left: 0}; if ("Fixed" === S.css (r, "position")) t = r.getBoundingClientRect (); else {t = this. offset (), n = r.ownerDocument, e = r.offsetParent || n.documentElement; while (e && (e === n.body || e === n.documentElement) && "static" === S .css (e, "position")) e = e.parentNode; e && e! == r && 1 === e.nodeType && ((i = S (e) .offset ()). top + = S.css (e, " borderTopWidth ",! 0), i.left + = S.css (e," borderLeftWidth ",! 0))} return {top: t.top-i.top-S.css (r," marginTop ",! 0 ), à esquerda: t.left-i.left-S.css (r, "marginLeft",! 0)}}}, offsetParent: function () {retorne isso.map (function () {var e = this.offsetParent; while (e && "static" === S.css (e, "position")) e = e.offsetParent; return e || re})}}), S.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, função (t, i) {var o = "pageYOffset" === i; S.fn [t] = function (e) {return $ (this, function (e, t, n) {var r; if (x (e)? r = e: 9 === tipo e.node && (r = e.defaultView), vazio 0 === n) retornar r ? r [i]: e [t]; r? r.scrollTo (o? r.pageXOffset: n, o? n: r.pageYOffset): e [t] = n}, t, e, argumentos. comprimento) }}), S.each (["top", "left"], função (e, n) {S.cssHooks [n] = $ e (y.pixelPosition, função (e, t) {if (t) return t = Be (e, n), Me.test (t)? S (e) .position () [n] + "px": t})}), S.each ({Height: "height", Largura: "largura"}, função (a, s) {S.each ({padding: "inner" + a, content: s, "": "outer" + a}, função (r, o) {S. fn [o] = função (e,t) {var n = argument.length && (r || "booleano"! = tipo de e), i = r || (! 0 === e ||! 0 === t? "margin": "border" ); return $ (esta, função (e, t, n) {var r; retorna x (e)? 0 === o.indexOf ("externo")? e ["interno" + a]: e.document .documentElement ["cliente" + a]: 9 === e.nodeType? (r = e.documentElement, Math.max (e.body ["rolagem" + a], r ["rolagem" + a], e .body ["deslocamento" + a], r ["deslocamento" + a], r ["cliente" + a])): void 0 === n? S.css (e, t, i): S. estilo (e, t, n, i)}, s, n? e: void 0, n)}})}), S.each (["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], função (e, t) {S.fn [t] = função (e) {retorna this.on (t, e)}}), S.fn.extend ({bind: function (e, t, n) {retorne this.on (e, null, t, n)}, desvincule: function (e, t) {retorne this.off (e, null, t)}, delegate: function ( e, t, n,r) {retorna this.on (t, e, n, r)}, undelegate: function (e, t, n) {retorna 1 === argumentos.length? this.off (e, "**"): this.off (t, e || "**", n)}, passe o mouse: function (e, t) {retorna this.mouseenter (e) .mouseleave (t || e)}}), S.each ( "desfoque foco foco em foco redimensionar rolagem clique dblclick mouse com mouse mousemove mouseover mouseout mouseenter mouseleave alterar selecionar enviar tecla pressionada tecla pressionada contexto menu de contexto" .split (""), função (e, n) {S.fn [n] = função (e, t ) {return 0 <argument.length? this.on (n, null, e, t): this.trigger (n)}}); var Gt = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g; S.proxy = function (e, t) {var n, r, i; if ("string" == tipo de t && (n = e [t], t = e, e = n), m (e)) retorna r = s.call (argumentos, 2), (i = function () {retorna e.apply (t || isso, r.concat (s.call (argumentos))) }). guid = e.guid = e.guid || S.guid ++, i}, S.holdReady = função (e) {e? S.readyWait ++: S.ready (! 0)}, S.isArray = Array.isArray, S.parseJSON = JSON.parse, S.nodeName = A, S.isFunction = m, S.isWindow = x, S.camelCase = X, S.type = w, S.now = Data. agora, S.isNumeric = function (e) {var t = S.type (e); return ("number" === t || "string" === t) &&! isNaN (e-parseFloat (e) )}, S.trim = function (e) {return null == e? "" :( e + ""). Replace (Gt, "")}, "function" == typeof define && define.amd && define ("jquery", [], function () {return S}); var Yt = C.jQuery, Qt = C. $; return S.noConflict = function (e) {return C. $ === S && (C. $ = Qt) , e && C.jQuery === S && (C.jQuery = Yt), S}, "indefinido" == tipo de e && (C.jQuery = C. $ = S), S});string "=== t) &&! isNaN (e-parseFloat (e))}, S.trim = função (e) {return null == e?" ":( e +" "). replace (Gt," " )}, "function" == tipo de definição && define.amd && define ("jquery", [], function () {return S}); var Yt = C.jQuery, Qt = C. $; return S.noConflict = function (e ) {return C. $ === S && (C. $ = Qt), e && C.jQuery === S && (C.jQuery = Yt), S}, "indefinido" == tipo de e&& (C.jQuery = C. $ = S), S});string "=== t) &&! isNaN (e-parseFloat (e))}, S.trim = função (e) {return null == e?" ":( e +" "). replace (Gt," " )}, "function" == tipo de definição && define.amd && define ("jquery", [], function () {return S}); var Yt = C.jQuery, Qt = C. $; return S.noConflict = function (e ) {return C. $ === S && (C. $ = Qt), e && C.jQuery === S && (C.jQuery = Yt), S}, "indefinido" == tipo de e&& (C.jQuery = C. $ = S), S});indefinido "== tipo de e && (C.jQuery = C. $ = S), S});indefinido "== tipo de e && (C.jQuery = C. $ = S), S});
